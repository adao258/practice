# 变化侦测

- 渐进式框架: 就是把框架分层 视图层渲染->组件机制->路由机制->状态管理->构建工具。有一个现成的服务端应用，非单页应用，可以将 vue.js 作为改应用的一部分嵌入其中，带来更加丰富的交互体验
- 渲染: 从状态生成 dom，在输出到用户界面显示的一整套流程叫作渲染

-

## Object 变化侦测

- 追踪变化: 利用 Object.defineProperty()可以侦测对象变化，利用 get 读取数据，set 设置数据
- 我们之所以要观察数据，其目的是当数据的属性发生变化时，可以通知那些曾经使用了该数据的地方，因此就要收集依赖，把之前收集好的依赖循环触发一遍就好，在 getter 里面收集依赖，在 setter 里面触发依赖
- 收集依赖: 观察数据的原因是因为，要知道哪些被观察的数据的属性发生改变，可以通知那些曾经使用了该数据的地方，因此就需要收集依赖，把用到该数据的地方收集起来，当属性发生变化时，再把收集好的依赖循环遍历一边就好了
- 假设依赖存在于 window.target 上，可以用一个数组，当读取(get)数据的时候就把依赖保存进数组，当获取(set)数据的时候，就会遍历获取到的依赖
- 依赖是谁: 收集什么?换句话说，当属性发生变化后，通知谁，我们要通知用到数据的地方，而使用这个数据的地方的有很多。因此把他们抽象成 Watcher
- 注意 getter/setter 只能追踪一个数据是否被修改，而不能侦测他的添加和删除属性，因此提供了 vm.$set   vm.$delete

## Watcher

- watcher 是一个中介角色，数据发生变化时通知他，然后再通知其他地方
- 但是这种侦测只能监听一层，如果要监听深度的呼气就需要递归所有

## Array 的变化侦测

- 因为 array 会通过原型上的方法来改变数据，所以不会触发 getter/setter,也就不能检测数据变化了
- 如何追踪变化:使用拦截器覆盖 Array.prototype,每当使用 Array 原型上的方法操作数组时，其实执行的都是拦截器中的方法，然后在拦截器中使用原生的 Array 的原型方法去操作数组
- Array 原型中可以改变数组自身内容的方法有七个 push,pop,shift,unshift,splice,sort,reverse

## 变化侦测相关的 api 实现

- vm.$watch(expOrFn,callback,[options]) 要观测的属性；回调函数，也可以是纯对象(要包含 handle 属性)；deep 深度观测 immediate 立即执行回调
  - 用于观察一个表达式或 computed 函数在 Vue.js 实力上的变化，回调函数调用时会从参数得到新数据和旧数据
- vm.$set(target,key,value)
  - 在 object 上设置一个属性，如果 object 响应式的，并且触发视图更新，这个方法主要用来避开 vue 不能侦测属性被添加的限制(也就是说可以监听属性，vue 会保证属性被创建后也是响应式的何时被添加删除)
- vm.$delete(target,key)(响应式的)删除数据中的某个属性
-
-
-
-
-
