一.javascript的组成
    1.ECMAScript：JavaScript 的语法标准。包括变量、表达式、运算符、函数、if语句、for语句等。
    2.DOM：Document Object Model（文档对象模型），操作页面上的元素的API。
      比如让盒子移动、变色、改变大小、轮播图等等。
    3.BOM：Browser Object Model（浏览器对象模型），操作浏览器部分功能的API。通过BOM可以操作浏览器窗口，
      比如弹框、控制浏览器跳转、获取浏览器分辨率等等。
      Js是解释型语言，边翻译，边执行
      Js有三种引入方式：行内式 内嵌式 引入外部的Js文件
      alter()弹框 可以直接使用
      prompt()弹框 不能直接使用 得设置一个变量来接受用户输入的内容

二.变量
    字面量(常量)：数字和字符串，布尔字面量
    变量的概念：用于存放数据的容器。 本质：变量是程序在内存中申请的一块用来存放数据的空间
    变量的声明(定义)： 
      var 定义变量 无块级作用域概念 可跨块级作用域访问 不能跨函数访问 并且可以变量提升
      let 定义变量 只能在块级作用域访问 其他都不行
      const 定义常量 初始化需要赋值 一旦赋值不能修改
    变量的赋值：var a=100;  const b=hello;  let c=word; 
    变量的初始化:声明一个变量并赋值。一般将声明和定义写在一起。
    补充：
    修改变量的值，
    同时声明多个变量；var name = '千古', age = 27, number = 100;
    变量声明的特殊情况：1.先声明在赋值 2.不声明只赋值 3.只声明不赋值(未定义)
    变量的命名规范：大小写敏感
    标识符：在Js中所有的可以由我们自主命名的都可以成为标识符
    关键字：Js本身已经使用的单词，不能再被使用
    保留字：预留关键字，未来可能成为关键字同样不能用它做标识符等

三.变量的数据类型
    js一共有六种数据类型
    基本数据类型(值类型);String ,Number,Boolean,Null,Undefined
    引用数据类型(引用类型);Object 除了基本的五种数据类型其他都是Object类型
      例如：Function Array Date RegExp Error 都是Object类型
    数据类型最大的区别:
      基本数据类型：参数赋值的时候传数值
      引用数据类型：参数赋值的时候 传地址
    栈内存和堆内存：
      Js中，所有的变量都保存在栈内存中
      基本数据类型：直接保存在栈内存中，值与值之间独立存在，修改一个变量不会影响其他变量
      引用数据类型：对象是保存在堆内存中的，每创建一个新对象，就会在堆内存中开辟一个新空间，而变量保存了对象的内存地址（对象的引用），保存在栈内存当中
        如果两个变量保存了同一个对象的引用，当另一个通过变量修改属性时，另一个也会修改

四.基本数据类型String和Boolean
    转义字符：\" = "  \' = ' \\=\  \r=回车  \n=换行  \t=缩进  \b=空格
    反引号：`Hello`.//反引号可将变量嵌入到字符串中，在引号内，也可进行简单运算
    let name = he ;
    alert (`Hello, ${name}!`)  // hello,he
    获取字符串长度：一个中文 一个英文 一个标点符号(中文 英文) 一个空格都可以表示一个字符串 
    字符串拼接
    模板字符串：console.log(`我是${name},age:${age}`); //ES6 写法
      模板字符串支持换行 调用函数 嵌套使用
    布尔值Boolean

五.基本数据类型Number
    数值型：Number,在Js中所有的数值都是Number型，包括整数和小数
    数值范围：Number.MAX_VALUE 这个值为： 1.7976931348623157e+308
             Number.MIN_VALUE 这个值为： 5e-32
             如果使用的Number超过了最大值，则返回infinity
    NaN：是一个特殊的数字，表示not a number 非数值
    隐式转换
    浮点数运算：在JS中，整数的运算基本可以保证精确；但是小数的运算，可能会得到一个不精确的结果。
    处理数学运算的精度问题：运用数学运算的开源库比如decimal.js、 Math.js
    变量值的赋值：将等号右边的值，赋给左边的变量；等号右边的变量，值不变
    
六.基本数据类型Null和Undefined
    Null：如果你想定义一个变量用来保存引用类型，但是还没想好放什么内容，这个时候，可以在初始化时将其设置为 null。
    Undefined 未定义时的情况：变量已声明未赋值时；变量未定义时；函数无返回值时；调用函数时未传参数

七.typeof和数据类型转换
    变量的数据类型转换(转换为字符串类型，数字型，布尔型)
    typeof运算：typeof()表示获取变量的数据类型
    变量的类型转换
      显示类型转换：toString() String() Number() parseInt(string) parseFloat(string) Boolean()
      隐式转换：isNaN(); 自增/自减运算符：++ -- ; 正负号 +a -a  ;加号 +;运算符，- * /
      隐式转换(特殊)
        逻辑运算符：
        关系运算符：
      一.使用Number()函数：
        情况一：字符串 --> 数字
            1.如果字符串中是纯数字，则直接将其转换为数字
            2.如果字符串是一个空串或者是一个全是空格的字符串，则转换为 0。
            3.只要字符串中包含了其他非数字的内容（小数点按数字来算），则转换为 NaN。
        情况二：布尔 --> 数字
            true转换成1 false转换成0
        情况三：null --> 数字
            结果为0
        情况四：undefined --> 数字
            结果NAN
      二.使用parseInt()函数：字符串-->整数
        parseInt()的作用是将字符串中的有效的整数内容转为数字
        parseFloat()的作用将字符串中的有效数字转换为浮点数，可以取小数点后面的数字
        情况一：字符串 --> 数字
            1.只保留字符串最开头的数字，后面的中文自动消失
            2.如果字符串不是以数字开头，则转换为 NaN
            3.如果字符串是一个空串或者是一个全是空格的字符串，转换时会报错
        情况二：Boolean --> 数字
            结果NAN
        情况三：Null --> 数字
            结果NAN
        情况四：Undefined --> 数字
            结果NAN
        注意：
            number()前方百计的想转换为数字
            parseInt()如果是数字则先转换为字符串，在把开头的数字部分取出来，并且只会取整(不会四舍五入)，没取出来就返回NAN
            parseInt()带两个参数时，表示在转换时，包含了进制转换(输出一定为十进制)
            var a = '110';
            var num = parseInt(a, 16); // 【重要】将 a 当成 十六进制 来看待，转换成 十进制 的 num
            console.log(num);
      三.转换为Boolean
            情况一：数字 --> 布尔。除了 0 和 NaN，其余的都是 true。也就是说，Boolean(NaN)的结果是 false
            情况二：字符串 ---> 布尔。除了空串，其余的都是 true。全是空格的字符串，转换结果也是 true。字符串'0'的转换结果也是 true。
            情况三：null 和 undefined 都会转换为 false
            情况四：引用数据类型会转换为 true。注意，空数组[]和空对象{}，转换结果也是 true，这个一点，很多人都不知道。
            总结: 0 NAN 空串 null undefined   都为false  
            补充：16进制0x开头 8进制0开头 2进制0b开头 但不是所有浏览器都支持，所以调用parseInt()转成数字时，使用两个参数
      四.隐式类型转换
            隐式类型转换，内部调用的都是显式类型的方法
            isNaN() 函数：判断指定的参数是否为 NaN（非数字类型），返回结果为 Boolean 类型
            执行过程：
           （1）先调用Number(参数)函数；
           （2）然后将Number(参数)的返回结果和NaN进行比较。 
      
八.运算符
    运算符的定义：也叫操作符，是一种符号。通过运算符可以对一个或多个值进行运算，并获取运算结果。
    表达式:由数字、运算符、变量的组合（组成的式子）
    运算符的分类：
      算数运算符 自增自减运算符 一元运算符 逻辑运算符 赋值运算符 比较运算符 三元运算符
        与运算的返回结果（以多个非布尔值的运算为例）：&&
          第一个为false 执行一 返回一 不会在执行
          第一个为true 执行二 返回二 如果全true 返回最后一个true
        或运算的返回结果（以多个非布尔值的运算为例）：||
          第一个true 执行一 返回一 不会在执行
          第一个false 执行二 返回二 如果全是false 返回最后一个
        当前端成功调用一个接口后，返回的数据为 result 对象,这个时候，我们用变量 a 来接收 result 里的图片资源。
        if (result.resultCode == 0) {
	    var a = result && result.data && result.data.imgUrl || 'http://img.smyhvae.com/20160401_01.jpg';
        }
        获取返回结果中的result.data.imgUrl这个图片资源；如果返回结果中没有 result.data.imgUrl 这个字段，
        就用 http://img.smyhvae.com/20160401_01.jpg 作为兜底图片
    比较运算得到的结果为布尔值，但两个字符串比较会使用Unicode编码，是的结果不相符，我们可以先转为数值型在比较，用parseInt()
    ??      空值合并运算符  他会返回第一个已定义的值 换句话说，如果第一个参数不是 null/undefined，则 ?? 返回第一个参数。否则，返回第二个参数。
        let height = 0;
        alert(height || 100); // 100
        alert(height ?? 100); // 0

九.流程控制语句：选择结构(if和switch)
    流程控制语句分类：
      代码块：用{}包围起来的就是代码块
      顺序结构:if语句
        条件判断语句：if
        条件分支语句：if else； switch语句
        if语句的嵌套
        switch语句：                                                     
                switch(表达式) {
	            case 值1：
		        语句体1;
		        break;
	            case 值2：
		        语句体2;
		        break;
                default：
		        语句体 n+1;
		        break;
                            }
        switch语句的结束与default无关，break就是结束命令。要注意case穿透情况，没有break

十.流程控制语句：循环结构
    for循环:    for(①初始化表达式; ②条件表达式; ④更新表达式){
	                    ③语句...
                }
    while循环语句:  while(条件表达式){
	                语句...
                    }

    do...while循环语句:
                            do{
	                        语句...
                            }while(条件表达式)
    while和do while 的区别：while先判断，后执行。do while 先执行，后判断。后者可以保证程序至少执行一次。

    break和continue：
    break 可以用来退出 switch 语句或退出整个循环语句
     （循环语句包括 for 循环、while 循环。不包括 if。if 里不能用 break 和 continue，否则会报错）
      break会立即终止离他最近的循环语句。可以为循环语句创建一个 label，来标识当前的循环（格式：label:循环语句）。
      使用 break 语句时，可以在 break 后跟着一个 label，这样 break 将会结束指定的循环，而不是最近的。

    continue:跳过当此循环，继续下一次循环
    同样，continue 默认只会离他最近的循环起作用。
    同样，如果需要跳过指定的当次循环，可以使用 label 标签。
        for (var i = 0; i < 10; i++) {
        if (i % 2 == 0) {
        continue;
        }
        console.log('i的值:' + i);
        }
        输出结果为1，3，5，7，9     

十一.对象简介
    面向对象简介：可以创建自定义类型，很好的支持继承和多态。特征：封装 继承 多态
    对象概念：对象是一组无序的相关属性和方法集合
    对象的作用：封装信息。
    对象的属性值可以是任何的数据类型，也可以是个函数，也可以是对象
    对象和数据类型的关系：
      数据类型分类：基本数据类型5种: String Number Boolean Null Undefined 
                   引用数据类型:Object
                   基本数据类型：他的值直接保存在栈内存中，值之间是相互独立的，修改一个不会影响另一个
                   引用数据类型：1.只要不是基本数据类型，就全是对象
                                2.如果使用基本数据类型的数据，我们所创建的变量是独立的，不能成为一个整体。
                                3.对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性
                                4.对象是保存到堆内存中的，每创建一个新的对象，就会在堆内存中开辟出一个新的空间。变量保存的是对象的内存地址（对象的引用）
                                5.换而言之，对象的值是保存在堆内存中的，而对象的引用（即变量）是保存在栈内存中的。
                                6.如果两个变量保存的是同一个对象引用，当一个通过一个变量修改属性时，另一个也会受到影响。
    传值和传址：对于引用类型的数据，赋值相当于地址拷贝，a、b指向了同一个堆内存地址。所以改了b，a也会变；
               如果你打算把引用类型 A 的值赋值给 B，让A和B相互不受影响的话，可以通过 Object.assign() 来复制对象
    对象的分类：内置对象 宿主对象 自定义对象
               1.内置对象：
                由ES标准中定义的对象，在任何的ES的实现中都可以使用
                比如：Object、Math、Date、String、Array、Number、Boolean、Function等。
               2.宿主对象：
                由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象。
                比如 BOM DOM。比如console、document。
               3.自定义对象：
                由开发人员自己创建的对象
                通过 new 关键字创建出来的对象实例，都是属于对象类型，比如Object、Array、Date等。
    Symbol:
        根据规范，对象的属性键只能是字符串类型或者 Symbol 类型。不是 Number，也不是 Boolean，只有字符串或 Symbol 这两种类型。
        let id = Symbol("id");
        Symbol 不会被自动转换为字符串
        Symbol 允许我们创建对象的“隐藏”属性，代码的任何其他部分都不能意外访问或重写这些属性。
        Symbol作为属性的键来保存属性的值
            let user = { // 属于另一个代码
            name: "John"
            };
            let id = Symbol("id");
            user[id] = 1;
            alert( user[id] ); // 我们可以使用 Symbol 作为键来访问数据
                如果我们要在对象字面量 {...} 中使用 Symbol，则需要使用方括号把它括起来
                [id]: 123 // 而不是 "id"：123[id]: 123 // 而不是 "id"：123
                这是因为我们需要变量 id 的值作为键，而不是字符串 “id”。
            Symbol 在 for…in 中会被跳过
            相反，Object.assign 会同时复制字符串和 symbol 属性：
        创建全局Symbol：Symbol.for(key)。

十二.基本包装类型
    基本数据类型不能绑定属性和方法，引用数据类型可以
    基本包装类型3个
      String()将基本数据类型字符串，转为String对象
      Number()将基本数据类型的数字，转换为Number对象
      Boolean()将基本数据类型的布尔值，转换为Boolean对象
    基本包装类型的作用
    在底层，字符串以字符数组的形式保存

十三.内置对象String字符串的常见方法
    Arguments 函数参数集合；Array 数组； 
    Boolean 布尔对象；Math 数学对象； 
    Date 日期时间；Error 异常对象；
    Function 函数构造器；Number 数值对象；
    Object 基础对象； RegExp 正则表达式对象；
    String 字符串对象

    查找字符串：indexOf() lastIndexOf() 获取字符串中指定内容的索引，可设两个参数
               search() 获取字符串中指定内容的索引(参数里一般是正则)
               includes() 字符串中是否包含指定内容
               startsWith() 字符串是否以指定内容开头
               endsWith() 字符串是否以指定内容结尾
    获取指定位置的字符：charAt(index); str[index]; charCodeAt(index);
    字符串截取：slice(); substring(); substr(); String.formCharCode(); concat();
    字符串转化为数组:split(); 
    字符串替换：replace(); 
    重复字符串：repeat();
    去除字符串前后的空白：trim();
    大小写转化：toLowerCase  toUpperCase

十四.内置对象Number和Math
    内置对象Number的常见方法：
      判断是否为整数 布尔值=Number.isInteger(数字);
      小数点后面保留多少位 字符串=myNum.toFixed(num);
    内置对象Math的常见方法：
    Math.PI  圆周率
    Math.abs()	返回绝对值	
    Math.random()	生成0-1之间的随机浮点数	取值范围是 [0，1)
                    生成 [0, x) 之间的随机数： Math.round(Math.random()*x)
                    生成 [x, y) 之间的随机数： Math.round(Math.random()*(y-x)+x)
                    生成 [x, y]之间的随机整数：(要包含这两个整数，可封装成一个方法)
                    function getRandom(min max){
                        return Math.floor(Math.random()*(max+1-min))+min;
                    }
                    console.log(getRandom(1,10))
    Math.floor()	向下取整（往小取值）	
    Math.ceil()	向上取整（往大取值）	
    Math.round()	四舍五入取整（正数四舍五入，负数五舍六入）	   
    Math.max(x, y, z)	返回多个数中的最大值	
    Math.min(x, y, z)	返回多个数中的最小值	
    Math.pow(x,y)	乘方：返回 x 的 y 次幂	
    Math.sqrt()	开方：对一个数进行开方运算

十五.内置对象Date
    创建Date对象:
        不写参数时返回当前时间对象：
        var date1 = new Date();
        console.log(date1);
        写参数时表示获取指定时间的时间对象。参数中既可以传递字符串，也可以传递数字，也可以传递时间戳：
    日期的格式化：
              getFullYear()	获取年份
              getMonth()	获取月： 0-11
              getDate()	获取日：1-31
              getDay()	获取星期：0-6
              getHours()	获取小时：0-23
              getMinutes()	获取分钟：0-59
              getSeconds()	获取秒：0-59
              getMilliseconds()	获取毫秒

              var myDate = new Date();
              console.log(myDate);
              console.log(myDate.getFullYear());
    获取时间戳：指的是从格林威治标准时间的1970年1月1日，0时0分0秒到当前日期所花费的毫秒数（1秒 = 1000毫秒）。
               计算机底层在保存时间时，使用的都是时间戳。时间戳的存在，就是为了统一时间的单位。
            getTime():获取时间戳
            获取Date对象的时间戳：
            const timestamp1 = +new Date();
            console.log(timestamp1);
            或：console.log(Date.now());获取当前对象的时间戳

十六.数组简介、
    创建数组对象：1.使用字面量创建数组 var arr2 = [1, 2, 3];
            2.使用构造函数创建数组 let arr = new Array(参数);
    数组的基本操作：
      数组的索引
        向数组中添加元素：数组[索引] = 值;
        获取数组中元素：数组[索引];超过会未定义
        获取数组长度：数组的长度 = 数组名.length；
            对于连续的数组，使用 length 可以获取到数组的长度（元素的个数）；
            对于非连续的数组，使用 length 会获取到数组的最大的索引+1。
        修改数组长度：如果修改的 length 大于原长度，则多出部分会空出来，置为 null。
                    如果修改的 length 小于原长度，则多出的元素会被删除，数组将从后面删除元素。
        遍历数组：for循环

十七.数组的常见方法
    数组的类型相关
    方法	          描述	
    Array.isArray()	 判断是否为数组	
    toString()	     将数组转换为字符串	
    Array.from(arrayLike)	将伪数组转化为真数组	
    Array.of(value1, value2, value3)	创建数组：将一系列值转换成数组	
    
    数组元素的添加与删除
    方法	描述	备注
    push()	向数组的最后面插入一个或多个元素，返回结果为新数组的长度	             会改变原数组
    pop()	删除数组中的最后一个元素，返回结果为被删除的元素	                     会改变原数组 
    unShift()	在数组最前面插入一个或多个元素，返回结果为新数组的长度             	会改变原数组
    shift()	删除数组中的第一个元素，返回结果为被删除的元素	会改变原数组
    slice()	从数组中提取指定的一个或多个元素，返回结果为新的数组	                不会改变原数组
    splice()	从数组中删除指定的一个或多个元素，返回结果为被删除元素组成的新数组	  会改变原数组
    fill()	填充数组：用固定的值填充数组，返回结果为新的数组	                     不会改变原数组
    
    数组的合并与拆分
    方法	描述	备注
    concat()	合并数组：连接两个或多个数组，返回结果为新的数组	不会改变原数组
    join()	将数组转换为字符串，返回结果为转换后的字符串	      不会改变原数组
    split()	将字符串按照指定的分隔符，组装为数组	             不会改变原字符串

    数组排序
    方法	描述	                                                                  备注
    reverse()	反转数组，返回结果为反转后的数组	           会改变原数组
    sort()	对数组的元素,默认按照Unicode 编码，从小到大进行排序	会改变原数组
                let arr = [5, 2, 11, 3, 4, 1];
                // 自定义排序规则：升序排列
                let result = arr.sort((a, b) => a - b);
                console.log('arr =' + JSON.stringify(arr));
                console.log('result =' + JSON.stringify(result));

    查找数组的元素
    方法	描述	备注
    indexOf(value)	从前往后索引，检索一个数组中是否含有指定的元素 返回值为0，说明以查询元素开始，-1说明没有这个元素
    lastIndexOf(value)	从后往前索引，检索一个数组中是否含有指定的元素	
    includes(item)	数组中是否包含指定的内容	
    find(function())	找出第一个满足「指定条件返回 true」的元素	
    findIndex(function())	找出第一个满足「指定条件返回 true」的元素的 index	
    every()	确保数组中的每个元素都满足「指定条件返回 true」，则停止遍历，此方法才返回 true	全真才为真。要求每一项都返回 true，最终的结果才返回 true
    some()	数组中只要有一个元素满足「指定条件返回 true」，则停止遍历，此方法就返回 true	一真即真。只要有一项返回 true，最终的结果就返回 true

    遍历数组
        方法	描述	备注
    for 循环	这个大家都懂	
    forEach()	和 for 循环类似，但需要兼容 IE8 以上	forEach() 没有返回值。也就是说，它的返回值是 undefined
        let myArr = ['王一', '王二', '王三'];
        myArr.forEach((item, index, arr) => {
        console.log('item:' + item);
        console.log('index:' + index);
        console.log('arr:' + JSON.stringify(arr));
        console.log('----------');
        如果要修改元素使用参数2，3来进行修改 如：arr[index] = arr[index] * 2;
    map()	对原数组中的每一项进行加工，将组成新的数组	不会改变原数组(推荐使用)
        arr.map(function (item, index, arr) {
        return newItem;
        });
        解释：对数组中每一项运行回调函数，返回该函数的结果，组成的新数组（返回的是加工之后的新数组）。不会改变原数组。
        作用：多数徐中的每一项进行加工
    filter()	(筛选)过滤数组：返回结果是 true 的项，将组成新的数组，返回结果为新的数组	不会改变原数组
        arr.filter(function (item, index, arr) {
        return true;
        });
    reduce	接收一个函数作为累加器，返回值是回调函数累计处理的结果	(可用于求和，统计某个元素出现的次数，求最大值，求平均值，二维数组转化为一维数组)
        arr.reduce(function (previousValue, currentValue, currentIndex, arr) {}, initialValue);
        previousValue：必填，上一次调用回调函数时的返回值
        currentValue：必填，当前正在处理的数组元素
        currentIndex：选填，当前正在处理的数组元素下标
        currentIndex：选填，当前正在处理的数组元素下标
        initialValue：选填，可选的初始值（作为第一次调用回调函数时传给 previousValue 的值）

十八.函数
    i++  返回旧值   ++i  返回新值
    函数的定义：
        1.利用函数关键字function自定义函数(命名函数)
        2.函数表达式(匿名函数)，是指就是将匿名函数赋值给一个变量
        3.使用构造函数new Function()
    函数的调用方式：
        1.fn1();  或 fn2.call();
        2.通过对象的方法来调用.如果一个函数是作为一个对象的属性保存，那么，我们称这个函数是这个对象的方法。
        3.立即执行函数
        4.通过构造函数来调用
        5.绑定事件函数。var btn = document.getElementById('btn'); btn.onclick = function(){} 
        6.定时器函数
    函数名，函数体和整个函数的加载问题：函数名==整个函数体console.log(fn) == console.log(function fn(){alert(1)});
    函数的加载问题：JS加载的时候，只加载函数名，不加载函数体。所以如果想使用内部的成员变量，需要调用函数。
        fn()：调用函数。调用之后，还获取了函数的返回值。
        fn：函数对象。相当于直接获取了整个函数对象。
        break ：结束当前的循环体（如 for、while）
        continue ：跳出本次循环，继续执行下次循环（如 for、while）
        return ：1、退出循环。2、返回 return 语句中的值，同时结束当前的函数体内的代码，退出当前函数。
    立即执行函数：函数被调用完之后立即执行，立即执行函数往往只会执行一次。为什么呢？因为没有变量保存它，执行完了之后，就找不到它了。
    方法：函数也可以成为对象的属性，如果一个函数是作为一个对象的属性保存，那么，我们称这个函数是这个对象的方法。调用这个函数就说调用对象的方法（method）
    类数组arguments：在调用函数时，浏览器每次都会传递进两个隐含的参数：
        1.函数的上下文对象 this
        2.封装实参的对象 arguments
        arguments 是一个类数组对象，它可以通过索引来操作数据，也可以获取长度。
        arguments 代表的是实参。在调用函数时，我们所传递的实参都会在 arguments 中保存。有个讲究的地方是：arguments只在函数中使用。
            1、返回函数实参的个数：arguments.length
            2、返回正在执行的函数：arguments.callee
            3、arguments 可以修改元素
            所有函数都内置了一个 arguments 对象（只有函数才有 arguments 对象），arguments 对象中存储了传递的所有实参.
            利用arguments求函数实参中的最大值

十九.作用域和变量提升
    作用域的概念：函数作用的范围
    作用域的分类：
        全局作用域：作用于整个 script 标签内部，或者作用域一个独立的 JS 文件。
        函数作用域(局部)：作用于函数内的代码环境。
    作用域的访问关系：内部可以访问外部，外部不能访问内部
    变量的作用域：
        全局变量：在全局作用域下声明的变量，叫「全局变量」。在全局作用域的任何一地方，都可以访问这个变量。只有浏览器关闭时才会被销毁，比较占内存。
        局部变量：定义在函数作用域的变量，叫「局部变量」。当其所在的代码块运行结束后，就会被销毁，比较节约内存空间。
    作用域的上下级关系：就近原则，由函数内往上一级寻找
    全局作用域：全局作用域在页面打开时创建，在页面关闭时销毁。创建的函数都会作为window对象的方法保存。
    变量的声明提前(变量提升)：使用var关键字声明的变量（ 比如 var a = 1），会在所有的代码执行之前被声明（但是不会赋值），不用var声明不会被提前
    函数的声明提前：使用函数声明的形式创建的函数function foo(){}，会被声明提前。也就是说，整个函数会在所有的代码执行之前就被创建完成。
    函数表达式：使用函数表达式创建的函数var foo = function(){}，不会被声明提前，所以不能在声明前调用。
    函数作用域：在函数作用域中也有声明提前的特性。在函数中使用关键字var会声明提前，没有var声明的变量都是全局变量，而且并不会提前声明。
    js在es6之前没有块级作用域
    作用域链：内部函数访问外部函数的变量，采用的是链式查找的方式来决定取哪个值，这种结构称之为作用域链。查找时，采用的是就近原则。
        只要是代码，就至少有一个作用域，
        写在函数内部是局部作用域
        如果函数中还有函数，则在作用域里面还有作用域

二十.预编译
    js运行：语法分析 预编译 解释执行
    预编译前奏：
        规律一：任何变量，如果未经声明就赋值，此变量是属于 window 的属性，而且不会做变量提升
        规律二：一切声明的全局变量，全是window属性
    函数预编译的步骤：
        （1）创建AO对象。AO即 Activation Object 活跃对象，其实就是「执行期上下文」
        （2）找形参和变量声明，将形参名和变量作为 AO 的属性名，值为undefined。
        （3）将实参值和形参统一，实参的值赋给形参。
        （4）查找函数声明，函数名作为 AO 对象的属性名，值为整个函数体。

二十一. this指向
    执行期上下文：当函数执行时（准确来说，是在函数发生预编译的前一刻），会创建一个执行期上下文的内部对象。
                  一个执行期上下文定义了一个函数执行时的环境。
                每调用一次函数，就会创建一个新的上下文对象，他们之间是相互独立且独一无二的。
                  当函数执行完毕，它所产生的执行期上下文会被销毁。
    this：解析器在调用函数每次都会向函数内部传递进一个隐含的参数，
      这个隐含的参数就是 this，this 指向的是一个对象，这个对象我们称为函数执行的 上下文对象。
    函数内的this指向;1.以函数包括普通函数、定时器函数、立即执行函数）调用时，this指向的永远都是window。比如fun();相当于window.fun();
                    2.以方法调用调用时，this指向调用方法的那对象。
                    3.以构造函数调用时，this指向实例对象
                    4.以事件绑定函数调用时，this指向绑定事件的对象
                    5.使用 call 和 apply 调用时，this 指向指定的那个对象
    箭头函数中this的指向：ES6 中的箭头函数并不会使用上面的准则，而是会继承外层函数调用的 this 绑定（无论 this 绑定到什么）。
    改变函数内部的this指向

二十二.call apply 和 bind
    call()方法的作用：可以调用一个函数，同时还会改变函数内部this的指向，因此它可以是实现继承
        fn1.call(想要将this指向哪里, 函数实参1, 函数实参2);
    apply()方法的作用：可以调用一个函数，同时还会改变函数内部this的指向，
        fn1.apply(想要将this指向哪里, [函数实参1, 函数实参2]);
        备注：第一个参数中，如果不需要改变 this 指向，则传 null。
    apply()方法 求数组的最大值，最小值
        const arr1 = [3, 7, 10, 8];
        const maxValue = Math.max.apply(Math, arr1); // 求数组 arr1 中元素的最大值
        console.log(maxValue);
    bind()方法的作用：不会调用函数，但是可以改变函数内部this的指向
        新函数 = fn1.bind(想要将this指向哪里, 函数实参1, 函数实参2);
        第一个参数：在 fn1 函数运行时，指定 fn1 函数的this 指向。如果不需要改变 this 指向，则传 null。
        其他参数：fn1 函数的实参。
        解释：它不会调用 fn1 函数，但会返回 由指定this 和指定实参的原函数拷贝。可以看出， bind() 方法是有返回值的。
    间谍装饰器  延时装饰器  防抖装饰器  节流装饰器 

二十三.高阶函数
    高阶函数的概念：当 函数 A 接收函数 B 作为参数，或者把函数 C 作为返回值输出时，我们称 函数 A 为高阶函数。
    
二十四.闭包(Closure )
    闭包的引入：指有权访问另一个函数作用域中变量的函数
    闭包的概念：如果这个作用域可以访问另外一个函数内部的局部变量，那就产生了闭包。
               而另外那个作用域所在的函数称之为闭包函数。注意，这里强调的是访问局部变量哦。
            function fn1() {
            let a = 10;
            function fn2() {
            console.log(a);
            }
            fn2();
            }
            fn1();
            函数 fn2 的作用域 访问了 fn1 中的局部变量，那么，此时在 fn1 中就产生了闭包，fn1 称之为闭包函数。
    闭包的作用：延申变量的作用范围

二十五.面向对象的概述
    面向过程: 先分析好的具体步骤，然后按照步骤，一步步解决问题。
        优点：性能比面向对象高，适合跟硬件联系很紧密的东西，例如单片机就采用的面向过程编程。
        缺点：没有面向对象易维护、易复用、易扩展。
    面向对象:以对象功能来划分问题，而不是步骤。
        优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护。
        缺点：性能比面向过程低。
    面向对象的编程思想：对代码和数据进行封装，并以对象调用的方式，对外提供统一接口。
    面向对象的特性：在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工。
                    面向对象编程具有灵活、代码可复用、容易维护和开发的优点，适合多人合作的大型软件项目，更符合我们认识事物的规律
                封装性 多态性 继承性
    js中的面向对象：JS 中的面向对象，是基于原型的面向对象。另外，在ES6中，新引入了 类（Class）和继承（Extends）来实现面向对象。
    基于原型的面向对象：JS 中的对象（Object）是依靠构造器（constructor）和原型（prototype）构造出来的。

二十六.对象的创建和构造函数 
    创建自定义对象的几种方法：
        一.对象字面量。对象的字面量就是一个{}。里面的属性和方法均是键值对。键：相当于属性名，值：相当于属性值，
            var obj = {};
        二.工厂模式new Object(),可大批创建对象
            var obj = new Object(); obj.name = name;obj.age = age;

            var obj = new Object();
            obj.name = '猪八戒';
            obj.age = 28;
            obj.gender = '男';
            obj.sayHi = function () {
            alert('hello world');
            };
            弊端：使用工厂方法创建的对象，使用的构造函数都是 Object。所以创建的对象都是 Object 这个类型，
            就导致我们无法区分出多种不同类型的对象。
        三.利用构造函数
            // 创建一个构造函数，专门用来创建Person对象
            function Person(name, age, gender) {
            this.name = name;
            this.age = age;
            this.gender = gender;
            this.sayName = function () {
            alert(this.name);
            };
            }
            var per = new Person('孙悟空', 18, '男');
            var per2 = new Person('玉兔精', 16, '女');
            var per3 = new Person('奔波霸', 38, '男');
            // 创建一个构造函数，专门用来创建 Dog 对象
            function Dog() {}
            var dog = new Dog();
    构造函数的概念：主要用来创建和初始化对象，也就是为对象的成员变量赋初始值。它与 new 一起使用才有意义。
    构造函数和普通函数的区别：构造函数习惯上首字母大写
                            构造函数和普通函数的区别就是调用方式的不同：普通函数是直接调用，而构造函数需要使用 new 关键字来调用。
                            this的指向不同：
                              1.以函数的形式调用时，this 永远都是 window。比如fun();相当于window.fun();
                              2.以方法的形式调用时，this 是调用方法的那个对象
                              3.以构造函数的形式调用时，this 是新创建的实例对象
    new一个构造函数的流程：
        1.开辟内存空间，在内存中创建一个新的空对象
        2.让this指向这个新对象
        3.执行构造函数里面的代码，给这个新对象添加属性和方法。
        4.返回这个新对象（所以构造函数里面不需要 return）。
        // 创建一个函数
        function Student(name) {
        this.name = name; //this指的是构造函数中的对象实例
        }
    静态成员和实例成员:JavaScript 的构造函数中可以添加一些成员，可以在构造函数本身上添加，也可以在构造函数内部的 this 上添加。
                     通过这两种方式添加的成员，就分别称为静态成员和实例成员。
                     静态成员：在构造函数本上添加的成员称为静态成员，只能由构造函数本身来访问。
                     实例成员：在构造函数内部创建的对象成员称为实例成员，只能由实例化的对象来访问。
    类 实例:使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类。通过一个构造函数创建的对象，称为该类的实例。
    instanceOf：使用 instanceOf 可以检查一个对象是否为一个类的实例。对象 instanceOf 构造函数;
    json的介绍:javaScript Object Notation（JavaScript 对象表示形式）。
    JSON 和对象字面量的区别：JSON 的属性必须用双引号引号引起来，对象字面量可以省略。
    json的遍历方法：
        <script>
        var myJson = {
        name: 'smyhvae',
        aaa: 111,
        bbb: 222,
        };
        //json遍历的方法：for...in...
        for (var key in myJson) {
        console.log(key); //获取 键
        console.log(myJson[key]); //获取 值（第二种属性绑定和获取值的方法）
        console.log('------');
        }
        </script>

二十七.对象的基本操作
    创建对象：使用 new 关键字调用的函数，是构造函数 constructor。构造函数是专门用来创建对象的函数。
    向对象中添加属性：对象.属性名 = 属性值;
    获取对象中的属性：对象.属性名; 规范起见使用obj['123'] = 789;要用[]把属性名括起来
    修改对象的属性：对象.属性名 = 新值;
    删除对象的属性：delete obj.name;
    in运算符：通过该运算符可以检查一个对象中是否含有指定的属性。如果有则返回 true，没有则返回 false。
        '属性名' in 对象;  console.log('name' in obj);
    for of 遍历数组：for ... of 的循环可以避免我们开拓内存空间，增加代码运行效率，所以建议大家在以后的工作中使用 for…of 遍历数组
                let arr1 = [2, 6, 8, 5];
                for (let value of arr1) {
                console.log(value);
                }
    Map 对象的遍历：for ... of既可以遍历数组，也可以遍历 Map 对象。
    for in 遍历对象的属性：：对象中有几个属性，循环体就会执行几次。每次执行时，会将对象中的每个属性的 属性名 赋值给变量。
                for (var key in obj) {
                console.log(key); // 这里的 key 是：对象属性的键（也就是属性名）
                console.log(obj[key]); // 这里的 obj[key] 是：对象属性的值（也就是属性值）
                }

二十八.深拷贝：拷贝多层数据，每一层的数据都会被拷贝
    浅拷贝：只拷贝最外面一层的数据，深层的只拷贝引用
    总结：拷贝引用的时候，是属于传址，而非传值。深拷贝会把对象里所有的数据重新复制到新的内存空间，是最彻底的拷贝。
    浅拷贝的实现方式：用 Object.assgin() 实现浅拷贝 ,object.assgin() 也可以实现几个数组合并
                语法1.   obj2 = Object.assgin(obj2, obj1);     
                语法2.   Object.assign(目标对象, 源对象1, 源对象2...);
                解释：将obj1 拷贝给 obj2。执行完毕后，obj2 的值会被更新。
                作用：将 obj1 的值追加到 obj2 中。如果对象里的属性名相同，会被覆盖。
    深拷贝的实现方式:
            for in  便利要拷贝的那个数组，然后用 新对象名[key] = 要拷贝目标的对象名[key];
            _.cloneDeep(object);
    数组合并：
        let user = { name: "John" };
        let permissions1 = { canView: true };
        let permissions2 = { canEdit: true };
        // 将 permissions1 和 permissions2 中的所有属性都拷贝到 user 中
        Object.assign(user, permissions1, permissions2);
        // 现在 user = { name: "John", canView: true, canEdit: true }

二十九.对象的高级操作
    冻结对象:Object.freeze()
        Object.freeze() 方法可以冻结一个对象。一个被冻结的对象再也不能被修改；
        冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。
        此外，冻结一个对象后该对象的原型也不能被修改。freeze() 返回和传入的参数相同的对象。
            const params = {
            name: 'qianguyihao';
            port: '8899';
            }
            Object.freeze(params); // 冻结对象 params
            params.port = '8080';// 修改无效

三十.原型链和原型继承
    在 ES6 中，我们可以通过 ES6 引入的类 Class 来实现面向对象的编程（下一篇文章会讲到）。
    但是在 ES6 之前，我们是通过构造函数和原型，来模拟类的实现机制。
    原型prototype的概念:
        我们所创建的每一个函数，解析器都会向函数中添加一个属性 prototype。这个属性对应着一个对象，这个对象就是我们所谓的原型对象.
        如果函数作为普通函数调用prototype没有任何作用，当函数以构造函数的形式调用时，它所创建的实例对象中都会有一个隐含的属性
        向该构造函数的原型，我们可以通过__proto__来访问该属性。  
    构造函数
    原型链规则
    原型链:
        原型对象也是对象，所以它也有原型，当我们使用或访问一个对象的属性或方法时：
            它会先在对象自身中寻找，如果有则直接使用；
            如果没有则会去原型对象中寻找，如果找到则直接使用；
            如果没有则去原型的原型中寻找，直到找到Object对象的原型。
            Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回 null

    instanceOf

三十一.类和构造继承

三十八.正则表达式
    正则表达式定义:正则表达式用于定义一些字符串的规则。
    正则表达式作用:计算机可以根据正则表达式，来检查一个字符串是否符合指定的规则；或者将字符串中符合规则的内容提取出来。
    创建正则表达式的对象:
        一.使用构造函数创建正则表达式的对象
            var 变量 = new RegExp("正则表达式"); // 注意，参数是字符串
            var 变量 = new RegExp("正则表达式", "匹配模式"); // 注意，两个参数都是字符串
                i 忽略大小写。这里的 i 指的是 ignore。
                g 全局匹配模式。这里的 g 指的是 global。
        创建了正则表达式的对象后，该怎么使用呢？大致分为两个步骤：
            （1）创建正则表达式的对象 reg。
            （2）使用 reg 的test() 方法，判断指定字符串是否符合规则。   
             myReg.test(str); // 判断字符串 str 是否符合 指定的 myReg 这个正则表达式的规则
        二.使用字面量创建正则表达式
            var 变量 = /正则表达式/;  // 注意，这个语法里没有引号
            var 变量 = /正则表达式/匹配模式;  // 注意，这个语法里没有引号
    全局匹配g慎用test()方法：对于非全局匹配的正则表达式，test()只会检测是否存在某个目标字符串（只要存在就为 true），多次检测的结果都相同。
            当设置全局标志 /g 时，一旦字符串中还存在匹配，test() 方法都将返回 true，同时匹配成功后将把 lastIndex 属性的值设置为上次匹配成功结果之后的第一个字符所在的位置
            下次匹配将从 lastIndex 指示的位置开始；匹配不成功时返回 false，同时将 lastIndex 属性的值重置为 0。
    全局匹配模式g一般用于 exec()、match()、replace()等方法。
    全局匹配模式g如果用于test()方法会有问题。因为g模式会生成一个lastIndex参数来存储匹配最后一次的位置
    正则表达式的简单语法：
        检查一个字符串中是否包含a或b
            var reg=/a|b/;
            var reg=/[ab]/;   []表示或
        一些规则：/a|b/  /[ab]/  检查一个字符串是否包含a或b
                /[a-z]/          检查一个字符串是否包含任意小写字母
                /[A-Z]/          检查一个字符串是否包含任意大写字母
                /[A-z]/          检查一个字符串是否包含任意字母
                /[0-9]/         检查一个字符串是否包含任意数字
                /a[bde]c/         检查一个字符串中是否包含abc adc aec 

                [^]                表示除了
                 var reg = /[^ab]/; // 规则：字符串中，除了a、b之外，还有没有其他的字符内容？
                 可以用来验证某字符串是否为纯数字
                 var reg = /[^0-9]/;  // 规则：字符串中，除了数字之外，还有没有其他的内容？
    支持正则表达式的String方法对象：
        split()	将字符串拆分成数组。var result = str.split(/[A-z]/); // 参数是一个正则表达式：表示所有字母
        search()	搜索字符串中是否含有指定内容，返回索引 index。result = str.search(/a[bef]c/); 他只会返回第一个，即使全局匹配也没用
        match()	根据正则表达式，从一个字符串中将符合条件的内容提取出来，可提取多个。var result3 = str.match(/[a-z]/gi); // 设置多个匹配模式，匹配字符串中 所有的字母（忽略大小写）	
        replace()	将字符串中的指定内容，替换为新的内容并返回，不会修改原字符串。 console.log(str2.replace(/today/gi,"tomorrow")); 
    常见正则表达式：
        检查一个字符串是否时一个合法的手机号
        去掉字符串开头和结尾的空格
        判断字符串是否为电子邮件

三十九.事件简介
    事件：就是文档或浏览器窗口中发生的一些特定的交互瞬间，点击某个元素、将鼠标移动至某个元素上方、关闭弹窗等等。
    事件三要素：事件源 事件 事件驱动程序
    JavaScript 是以事件驱动为核心的一门语言。JavaScript 与 HTML 之间的交互是通过事件实现的。
        事件源：引发后续事件的html标签。
        事件：js已经定义好了（见下图）。
        事件驱动程序：对样式和html的操作。也就是DOM。
    代码书写步骤：
        1）获取事件源：document.getElementById(“box”); // 类似于Android里面的findViewById
        2）绑定事件： 事件源box.事件onclick = function(){ 事件驱动程序 };
        3）书写事件驱动程序：关于DOM的操作。
    常见事件：
        onclick    单击鼠标
        ondblclick    双击鼠标
        onkeyup     按下并释放键盘上的一个键时触发
        onchange     文本内容或下拉菜单中的选项发生改变
        onfocus     获取焦点，表示文本框等获得鼠标光标
        onblur      失去焦点，表示文本框等食去鼠标光标
        onmouseover     鼠标悬停，即鼠标停留在图片等的上方
        onmouseout      鼠标移出，即鼠标离开图片等的上方
        onload      网页文档加载事件
        onunload    关闭网页时
        onsubmit        表单提交事件
        onreset     重置表单时
    1.获取事件源的方式(DOM节点获取)
        var div1 = document.getElementById("box1");
        var arr1 = document.getElementByTagName("div")
        var arr2 = document.getElementByClassName("hhhh");
    2.绑定事件方式
        一.直接绑定匿名函数
            var div1 = document.getElementById("box1");
                div1.onclick = function () {
                alert("我是弹出的内容");
                }
        二.先单独定义再绑定
            var div1 = document.getElementById("box1");
            div1.onclick = fn; //注意，这里是fn，不是fn()。fn()指的是返回值。
            function fn() {
            alert("我是弹出的内容");
            }
        三.行内绑定
            <div id="box1" onclick="fn()"></div>
            function fn() {
            alert("我是弹出的内容");
            }
    3.事件驱动程序
        在js里写属性值时，要用引号
        在js里写属性名时，是backgroundColor，不是CSS里面的background-color。
    onload 事件
        当页面加载（文本和图片）完毕的时候，触发onload事件。
        js的加载是和html同步加载的。因此，如果使用元素在定义元素之前，容易报错。
        这个时候，onload事件就能派上用场了，我们可以把使用元素的代码放在onload里，就能保证这段代码是最后执行。
        建议是：整个页面上所有元素加载完毕再执行js内容。所以，window.onload可以预防使用标签在定义标签之前。
        window.onload(){} 
        因为onload在加载多个方法时会覆盖前面的方法，因此使用 window.onload(){t();b();}

四十.DOM简介和DOM操作
    javascript的组成:
        ECMAScript：JavaScript的语法标准。包括变量、表达式、运算符、函数、if语句、for语句等。
        DOM：文档对象模型（Document object Model），操作网页上的元素的API。比如让盒子移动、变色、轮播图等。
        BOM：浏览器对象模型（Browser Object Model），操作浏览器部分功能的API。比如让浏览器自动滚动。
    节点:构成 HTML 网页的最基本单元。网页中的每一个部分都可以称为是一个节点，比如：html标签、属性、文本、注释、整个文档等都是一个节点。
        文档节点:整个html文档,整个html文档就是一个节点
        元素节点:html标签
        属性节点:元素的属性
        文本节点:html标签中的文本内容(包括标签之间的空格 换行)
        节点的类型不同，属性和方法也都不尽相同。所有的节点都是Object。
    什么是DOM:
        Document Object Model，文档对象模型。DOM 为文档提供了结构化表示，并定义了如何通过脚本来访问文档结构。目的其实就是为了能让js操作html元素而制定的一个规范。
        解析过程:HTML加载完毕，渲染引擎会在内存中把HTML文档，生成一个DOM树，
          getElementById是获取内中DOM上的元素节点。然后操作的时候修改的是该元素的属性。在HTML当中，一切都是节点
    DOM可以做什么:
        找对象(元素节点)
        设置元素的属性值
        设置元素样式
        动态创建和删除元素
        事件的触发响应：事件源 事件 事件驱动程序
    元素节点的获取：
        DOM节点的获取方式其实就是获取事件源的方式
        1.var div1 = document.getElementById("box1"); //方式一：通过 id 获取 一个 元素节点（为什么是一个呢？因为 id 是唯一的）
        2.var arr1 = document.getElementsByTagName("div"); //方式二：通过 标签名 获取 元素节点数组，所以有s
        3.var arr2 = document.getElementsByClassName("hebe"); //方式三：通过 类名 获取 元素节点数组，所以有s
        特殊情况：数组中的值只有1个。即便如此，这一个值也是包在数组里的。这个值的获取方式如下：
        document.getElementsByTagName("div1")[0];    //取数组中的第一个元素
        document.getElementsByClassName("hebe")[0];  //取数组中的第一个元素
    DOM访问关系的获取：DOM的节点并不是孤立的，因此可以通过DOM节点之间的相对关系对它们进行访问，节点的访问关系，是以属性的方式存在的。
        这里我们要重点知道parentNode和children这两个属性的用法。下面分别介绍。
        父节点：parentNode
        兄弟节点：nextSibling; nextElementSibling; previousSibling; previousElementSibling;
        子节点：firstChild; firstElementChild; lastChild; lastElementChild; 
        所有子节点：childNodes; children;
    获取父节点：节点.parentNode
    获取兄弟节点:
        下一个元素节点|下一个元素节点：nextSibling; nextElementSibling;
            下一个元素节点的兼容方式：下一个兄弟节点 = 节点.nextElementSibling || 节点.nextSibling
        前一个节点 | 前一个元素节点：previousSibling; previousElementSibling;
            前一个元素节点的兼容方式：前一个兄弟节点 = 节点.previousElementSibling || 节点.previousSibling
        任意一个节点的获取方式:节点自己.parentNode.children[index];  //随意得到兄弟节点
    获取单个子节点:
        第一个子节点|第一个子元素节点：firstChild; firstElementChild;
            第一个子元素节点 = 节点.firstElementChild || 节点.firstChild
        最后一个子节点 | 最后一个子元素节点：
            最后一个子元素节点 = 节点.lastElementChild || 节点.lastChild
    获取所有子节点：子节点数组 = 父节点.childNodes;   //获取所有节点。
                children：非标准属性。返回的是指定元素的子元素节点的集合。【重要】
                子节点数组 = 父节点.children;   //获取所有节点。用的最多。
    DOM节点的操作
    创建节点:新的标签(元素节点) = document.createElement("标签名");(可创建一个不存在的标签<asd></asd>)
    插入节点:
        方式一.父节点.appendChild(新的子节点);解释：父节点的最后插入一个新的子节点。
        方式二.父节点.insertBefore(新的子节点,作为参考的子节点);在参考节点前插入一个新的节点。如果参考节点为null，那么他将在父节点里面的最后插入一个子节点。
        特殊： <div class="box11">
                <div class="box12">生命壹号</div>
                </div>
                <div class="box21">
                <div class="box22">永不止步</div>
                </div>
            如果我调用方法box11.appendChild(box22)，最后产生的结果是：box22会跑到box11中，box22将不再box21中
    删除节点：父节点.removeChild(子节点);用父节点删除子节点。必须要指定是删除哪个子节点。
            删除节点本身：node1.parentNode.removeChild(node1);
    克隆节点：要复制的节点.cloneNode();//括号里不带参数和带参数false，效果是一样的。只复制节点本身
            要复制的节点.cloneNode(true);//既复制节点本身，也复制子节点
    获取节点属性值：元素节点.属性名;  元素节点[属性名];
    设置节点属性值： myNode.src = "images/2.jpg"   //修改src的属性值
                     myNode.className = "image2-box";  //修改class的name
                     元素节点.setAttribute("属性名", "新的属性值");
                    myNode.setAttribute("src","images/3.jpg");
    删除节点属性值：元素节点.removeAttribute(属性名);// myNode.removeAttribute("class");
    获取节点的属性值和设置节点的属性值都有两种方式，但如果都是节点的原始属性，获取和设置节点可以混用，不同则get set 不能混用
    DOM对象属性补充 innerHTML和innerText的区别
        value：标签的value属性。
        innerHTML：双闭合标签里面的内容（包含标签本身）
        innerText：双闭合标签里面的内容（不包含标签）。（老版本的火狐用textContent）
    nodeType nodeName nodeValue属性
        nodeType == 1 表示的是元素节点（标签） 。记住：在这里，元素就是标签。
        nodeType == 2 表示是属性节点。属性节点
        nodeType == 3 是文本节点。文本节点
    这三个节点的获取方式：
        var element = document.getElementById("box1");  //获取元素节点（标签）
        var attribute = element.getAttributeNode("id"); //获取box1的属性节点
        var txt = element.firstChild;                   //获取box1的文本节点
        var value = element.getAttribute("id");         //获取id的属性值
    文档的加载
        浏览器在加载一个页面时，是按照自上向下的顺序加载的，读取到一行就运行一行。如果将script标签写到页面的上边，
        在代码执行时，页面还没有加载，页面没有加载DOM对象也没有加载，会导致无法获取到DOM对象。

        onload 事件会在整个页面加载完成之后才触发。为 window 绑定一个onload事件，
        该事件对应的响应函数将会在页面加载完成之后执行，这样可以确保我们的代码执行时所有的DOM对象已经加载完毕了。
        
四十一.通过style对象获取和设置行内样式
    style属性的获取和修改:
        className:针对内嵌样式
        style：针对行内样式
        需要注意的是：style是一个对象，只能获取行内样式，不能获取内嵌的样式和外链的样式。例如：
    通过js读取元素样式：
          元素.style.样式名
          元素.style["属性"];  //格式
          box.style["width"];  //举例
    通过js设置元素样式：
         元素.style.样式名 = 样式值;
         box1.style.backgroundColor = "red"; // 驼峰命名法
    style属性的注意事项：
        1.样式少时使用
        2.style是对象。我们在上方已经打印出来，typeof的结果是Object。
        3.值是字符串，没有设置值是“”。
        4.命名规则，驼峰命名。
        5.只能获取行内样式，和内嵌和外链无关。
        6.box.style.cssText = “字符串形式的样式”。cssText这个属性，其实就是把行内样式里面的值当做字符串来对待。
    style属性的常用属性：
        backgroundColor
        backgroundImage
        color
        width
        height
        border
        opacity 设置透明度 (IE8以前是filter: alpha(opacity=xx))
        注意DOM对象style的属性和标签中style内的值不一样，因为在JS中，-不能作为标识符。比如：
        DOM中：backgroundColor   CSS中：background-color
    style属性举例
        改变div大小和透明度
        当前输入的文本框高亮显示
        高级隔行变色高亮显示
    通过js获取元素当前显示样式:
          window.getComputedStyle("要获取样式的元素", "伪元素");两个参数都是必须要有的。参数二中，如果没有伪元素就用 null 代替（一般都传null）
          obj.currentStyle;
            如果当前元素没有设置该样式，则获取它的默认值。
            该方法会返回一个对象，对象中封装了当前元素对应的样式，可以通过对象.样式名来读取具体的某一个样式。
            通过currentStyle和getComputedStyle()读取到的样式都是只读的，不能修改，如果要修改必须通过style属性。

四十二.offset相关属性和匀速动画(含轮播图)
    js动画三大家族 offset/scroll/client:
    事件对象/event（事件被触动时，鼠标和键盘的状态）（通过属性控制）。
    offset家族 offsetWidth；offsetHight；offsetLeft；offsetTop；offsetParent
        offsetWidth 和 offsetHight：获取元素的宽高 + padding + border，不包括margin。如下：
        offsetWidth = width + padding + border
        offsetHeight = Height + padding + border
        offsetParent: 获取当前元素的定位父元素
        如果当前元素的父元素,有css定位（position为absolute、relative、fixed）那么 offsetParent 获取的是最近的那个父元素。
        如果当前元素的父元素，没有CSS定位（position为absolute、relative、fixed），那么offsetParent 获取的是body。
    offsetLeft 和 offsetTop
        offsetLeft：当前元素相对于其定位父元素的水平偏移量。
        offsetTop：当前元素相对于其定位父元素的垂直偏移量。
        备注：从父亲的 padding 开始算起，父亲的 border 不算在内。
    offsetLeft和stye.left的区别
        区别一.
        offsetLeft 可以返回无定位父元素的偏移量。如果父元素中都没有定位，则body为准。
        style.left 只能获取行内样式，如果父元素中都没有设置定位，则返回""（意思是，返回空字符串）;
        区别二.
        offsetTop 返回的是数字，而 style.top 返回的是字符串，而且还带有单位：px。
        div.offsetLeft = 100;
        div.style.left = "100px";
        区别三.
        style.left:只能获取行内式，获取值可能为空，容易出现NAN
        offsetLeft：获取值特别方便，而且是现成的number，方便计算。它是只读的，不能赋值。
    动画的种类  闪现  匀速  缓动
        //方法1：用offsetLeft获取值，用style.left赋值。
        div.style.left = div.offsetLeft + 100 + 'px';
    匀速动画的封装
    轮播图的实现 

四十三.scroll相关属性缓动动画
    window.onScroll()方法;当我们用鼠标滚轮，滚动网页的时候，会触发 window.onscroll() 方法
    scrollWidth和scrollHeight：获取元素整个滚动区域的宽、高。包括 width 和 padding，不包括 border和margin。
        如果内容超出了盒子，scrollHeight为内容的高（包括超出的内容）；如果不超出，scrollHeight为盒子本身的高度。
        scrollWidth:同理
    scrollTop和scrollLeft：获取水平/垂直滚动条滚动的距离
        当某个元素满足scrollHeight - scrollTop == clientHeight时，说明垂直滚动条滚动到底了。
        当某个元素满足scrollWidth - scrollLeft == clientWidth时，说明水平滚动条滚动到底了。
    scrollTop的兼容性：
        如果文档没有 DTD 声明，写法为：document.body.scrollTop
        如果文档有 DTD 声明，写法为：document.documentElement.scrollTop
        document.body.scrollTop || document.documentElement.scrollTop //方式一
        document.body.scrollTop + document.documentElement.scrollTop  //方式二
        最终版的兼容性写法： window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop;
    判断是否已经DTD声明：
        document.compatMode === "CSS1Compat"   // 已声明
        document.compatMode === "BackCompat"   // 未声明
    将scrollTop和scrollLeft进行封装:我们将 scrollTop 和 scrollLeft 封装为一个方法，名叫scroll()，返回值为 一个对象。
        我们将 scrollTop 和 scrollLeft 封装为一个方法，名叫scroll()，返回值为 一个对象。
    获取html文档的方法：
        document.title 获取文档标题，
        document.head 文档的头部标签
        document.body 文档的body标签
        document.documentElement 表示文档的html标签。也就是说，基本结构当中的 html 标签而是通过document.documentElement访问的，并不是通过 document.html 去访问的。
        固定首页的导航栏
    缓动动画 三个函数 Math.ceil() 向上取整；Math.floor() 向下取整； Math.round(); 四舍五入；
    缓动动画原理：在移动的过程中步长越来越小
    设置步长为：目标位置和盒子当前位置的十分之一
    盒子位置 = 盒子本身位置 + (目标位置 - 盒子本身位置)/ 10；
    缓动动画的封装

四十四.client(可视区)相关属性
    client家族的组成:
        clientWidth:获取元素的可见宽度(width+padding)
        clientHeight：获取元素的可见高度（height + padding）
    clientWidth 和 clientHeight：获取网页可视区的宽高。
    声明：
        clientHeight：获取元素的可见高度（height + padding）。
        clientHeight：获取元素的可见高度（height + padding）。
    clientX 和 clientY：
        event调用
        clientX：鼠标距离可视区域左侧距离。
        clientY：鼠标距离可视区域上侧距离。
    clientTop 和 clientLeft
        clientTop：盒子的上border。
        clientLeft：盒子的左border
    三大家族 offset/scroll/client 的区别
        宽高：
            offsetWidth=width+border+padding
            offsetHeight=height+border+padding
            scrollWidth=width(内容宽度，不包含border)
            scrollHeight=height(内容高度，不包含border)
            clientWidth = width + padding
            clientHeight = height + padding
        上左：
            offsetTop/offsetLeft：
            调用者：任意元素。(盒子为主)
            作用：距离父系盒子中带有定位的距离。
            scrollTop/scrollLeft
            调用者：document.body.scrollTop（window调用）(盒子也可以调用，但必须有滚动条)
            作用：浏览器无法显示的部分（被卷去的部分）。
            clientY/clientX：
            调用者：event
            作用：鼠标距离浏览器可视区域的距离（左、上）。
        window.onresize事件指的是：在窗口或框架被调整大小时发生。各个事件的解释如下：
            window.onscroll 屏幕滑动
            window.onresize 浏览器大小变化
            window.onload 页面加载完毕
            div.onmousemove 鼠标在盒子上移动（注意：不是盒子移动）
    获取显示器分辨率: 
        window.onresize = function () {
        document.title = window.screen.width + "    " + window.screen.height;
        }

四十五.事件的绑定和事件对象event
    绑定事件的两种方式和DOM事件的级别:
        DOM0的写法：onclick
            element.onclick = function () { }
        DOM2的写法：addEventListener（高版本浏览器）
            element.addEventListener('click', function () { }, false);
            参数1：事件名的字符串(注意，没有on)
            参数2：回调函数：当事件触发时，该函数会被执行
            参数3：true表示捕获阶段触发，false表示冒泡阶段触发（默认）。如果不写，则默认为false。【重要】
            一个元素的一个事件，可以绑定多个响应函数。不存在响应函数被覆盖的情况。执行顺序是：事件被触发时，响应函数会按照函数的绑定顺序执行。
            addEventListener()中的this，是绑定事件的对象。
            addEventListener()不支持 IE8 及以下的浏览器。在IE8中可以使用attachEvent来绑定事件
        DOM2的写法：attachEvent（IE8及以下版本浏览器）
            element.attachEvent('onclick', function () { }); 
            参数1：事件名的字符串(注意，有on)
            参数2：回调函数：当事件触发时，该函数会被执行
            一个元素的一个事件，可以绑定多个响应函数。不存在响应函数被覆盖的情况。注意：执行顺序是，后绑定的先执行。
            attachEvent()中的this，是window
    兼容性写法：
        addEventListener()中的this，是绑定事件的对象。
        attachEvent()中的this，是window。
        可以封装这两个，判断this是谁，由谁调用
    事件对象
    event属性：
        attachEvent()中的this，是window。
        ie 678 的写法是 window.event。此时，事件对象 event 是作为window对象的属性保存的。
        event = event || window.event; // 兼容性写法
    event 属性：
        timeStamp：返回事件生成的日期和时间
        bubbles：返回布尔值，指示事件是否气泡事件类型
        button：返回事件被触发时，哪个鼠标按钮被点击
        pageX：光标相对于该网页的水平位置(ie无)
        pageY：光标相对于该网页的垂直位置(ie无)
        clientX:光标相对于该网页的水平位置(当前可视区)
        clientY:光标相对于该网页的垂直位置(当前可视区)
        target：该事件被传送到的对象
        type：事件类型
        screenX:光标相对于显示器的水平位置
        screenY:光标相对于显示器的垂直位置
        由于pageX 和 pageY的兼容性不好，我们可以这样做：
            鼠标在页面的位置 = 滚动条滚动的距离 + 可视区域的坐标。

四十六.事件的传播和事件冒泡 
    DOM事件流：
        事件捕获阶段：事件从祖先元素往子元素查找（DOM树结构），直到捕获到事件目标 target。在这个过程中，默认情况下，事件相应的监听函数是不会被触发的。
        事件目标：当到达目标元素之后，执行目标元素该事件相应的处理函数。如果没有绑定监听函数，那就不执行。
        事件冒泡阶段：事件从事件目标 target 开始，从子元素往冒泡祖先元素冒泡，直到页面的最上一级标签。
    事件捕获：
        addEventListener可以捕获事件：
        box1.addEventListener("click", function () {
        alert("捕获 box3");
        }, true);    参数为true，代表事件在捕获阶段执行。参数为false或者不写参数，代表事件在「冒泡」阶段触发
        重点：捕获阶段，事件依次传递的顺序是：window --> document --> html--> body --> 父元素、子元素、目标元素。
            window.addEventListener("click", function () {
        alert("捕获 window");
        }, true);

        document.addEventListener("click", function () {
        alert("捕获 document");
         }, true);

        document.documentElement.addEventListener("click", function () {
        alert("捕获 html");
        }, true);

        document.body.addEventListener("click", function () {
        alert("捕获 body");
        }, true);

        fatherBox.addEventListener("click", function () {
        alert("捕获 father");
        }, true);

        childBox.addEventListener("click", function () {
        alert("捕获 child");
        }, true);
        说明：
        第一个接收到事件的对象是 window（有人会说body，有人会说html，这都是错误的）。
        JS中涉及到DOM对象时，有两个对象最常用：window、document。它们俩是最先获取到事件的。
        在 js中：
        如果想获取 html节点，方法是document.documentElement。
        如果想获取 body 节点，方法是：document.body。
    事件冒泡：当一个元素上的事件被触发的时候（比如说鼠标点击了一个按钮），
             同样的事件将会在那个元素的所有祖先元素中被触发。这一过程被称为事件冒泡
    冒泡顺序：一般的浏览器: （除IE6.0之外的浏览器）
            div -> body -> html -> document -> window
            IE6.0：
            div -> body -> html -> document
    不是所有事件都能冒泡：
        blur、focus、load、unload、onmouseenter、onmouseleave。意思是，事件不会往父元素那里传递。
    检查一个事件是否冒泡：
        event.bubbles 如果返回值为true，说明该事件会冒泡；反之则相反。
    阻止冒泡：通俗来讲，冒泡指的是：子元素的事件被触发时，父元素的同样的事件也会被触发。取消冒泡就是取消这种机制。
        w3c的方法：（火狐、谷歌、IE11）  event.stopPropagation();
        IE10以下则是：event.cancelBubble = true

四十七.事件委托
    事件委托，通俗地来讲，就是把一个元素响应事件（click、keydown......）的函数委托到另一个元素。
    当我们的鼠标移到<a>标签上的时候，需要获取此<a>的相关信息并飘出悬浮窗以显示详细信息，或者当某个<a>被点击的时候需要触发相应的处理事件。
      我们通常的写法，是为每个<a>都绑定类似onMouseOver或者onClick之类的事件监听：

四十八.键盘事件
    鼠标拖拽事件：
        onmousedown：当鼠标在被拖拽元素上按下时，开始拖拽；
        onmousemove：当鼠标移动时被拖拽元素跟随鼠标移动；
        onmouseup：当鼠标松开时，被拖拽元素固定在当前位置。
    鼠标滚动事件：
        onmousewheel：鼠标滚轮滚动的事件，会在滚轮滚动时触发。但是火狐不支持该属性。
        DOMMouseScroll：在火狐中需要使用 DOMMouseScroll 来绑定滚动事件。注意该事件需要通过addEventListener()函数来绑定。
    键盘事件：
        onkeydown：按键被按下。
        onkeyup：按键被松开。
        如果一直按着某一个按键不松手，那么，onkeydown事件会一直触发。此时，松开键盘，onkeyup事件会执行一次。
        当onkeydown连续触发时，第一次和第二次之间会间隔稍微长一点，后续的间隔会非常快。这种设计是为了防止误操作的发生。
    判断哪个键盘被按下：
        可以通过event事件对象的keyCode来获取按键的编码。
        此外，event事件对象里面还提供了以下几个属性：
        altKey
        ctrlKey
        shiftKey
        上面这三个属性，可以用来判断alt、ctrl、和shift是否被按下。如果按下则返回true，否则返回false。

四十九.BOM简介
    常见的简单BOM对象：
        Window：代表整个浏览器的窗口，同时 window 也是网页中的全局对象。
        Navigator：代表当前浏览器的信息，通过该对象可以识别不同的浏览器。
        Location：代表当前浏览器的地址栏信息，通过 Location 可以获取地址栏信息，或者操作浏览器跳转页面。
        History：代表浏览器的历史记录，通过该对象可以操作浏览器的历史记录。由于隐私原因，该对象不能获取到具体的历史记录，
            只能操作浏览器向前或向后翻页，而且该操作只在当次访问时有效。
        Screen：代表用户的屏幕信息，通过该对象可以获取用户的显示器的相关信息
        备注：这些 BOM 对象都是作为 window 对象的属性保存的，可以通过window对象来使用，也可以直接使用。
            比如说，我可以使用 window.location.href，也可以直接使用 location.href，二者是等价的。
    Navigator和Navigator.userAgent：
        Navigator代表当前浏览器的信息，通过该对象可以识别不同的浏览器。
        一般我们只会使用navigator.userAgent来获取浏览器的信息。
        userAgent 的值是一个字符串，简称 UA，这个字符串中包含了用来描述浏览器信息的内容，不同的浏览器会有不同的userAgent。
    在电脑上模拟移动端浏览器
    不同浏览器的userAgent
    History对象的属性 方法
        History对象：可以用来操作浏览器的向前或向后翻页。
        属性：
        history.length： ：获取浏览器历史列表中的 url 数量。注意，只是统计当次的数量，如果浏览器关了，数量会重置为1。
        方法：
        history.back();用来回退到上一个页面，作用和浏览器的「回退按钮」一样。
        history.forward();用来跳转下一个页面，作用和浏览器的「前进按钮」一样。
        history.go( int n);  // 需要整数作为参数
        history.go( 1 ); // 向前跳转一个页面，相当于 history.forward()
        history.go( 1 ); // 向前跳转一个页面，相当于 history.forward()
        history.go( 0 ); // 刷新当前页面
        history.go( -1 ); // 向后跳转一个页面，相当于 history.back()
        history.go( -1 ); // 向后跳转一个页面，相当于 history.back()
    Location对象的属性 方法
        封装了浏览器地址栏的 URL 信息
        属性：
        location.href   解释：获取当前页面的 url 路径（或者设置 url 路径）
        location.href = 'https://xxx';
        方法：
        location.assign(str); 用来跳转到其他的页面，作用和直接修改location.href一样。
        location.reload(); 用于重新加载当前页面，作用和刷新按钮一样。
        location.reload(true); // 在方法的参数中传递一个true，则会强制清空缓存刷新页面。
        location.replace(); 使用一个新的页面替换当前页面，调用完毕也会跳转页面。但不会生成历史记录，不能使用「后退按钮」后退。

五十.定时器
    定时器的常见方法：
        setInterval()：循环调用。将一段代码，每隔一段时间执行一次。（循环执行）
        setTimeout()：延时调用。将一段代码，等待一段时间之后再执行。（只执行一次）
    setInterval() 的使用：
        参数1：回调函数，该函数会每隔一段时间被调用一次。
        参数2：每次调用的间隔时间，单位是毫秒
        返回值：返回一个Number类型的数据。这个数字用来作为定时器的唯一标识，方便用来清除定时器。
    定义定时器：
        方式一:匿名函数  每间隔一秒，将 数字 加1：
            let num = 1;
            setInterval(function () {
            num ++;
            console.log(num);
            }, 1000);
            方式二.   每间隔一秒，将 数字 加1：
                setInterval(fn,1000);
                function fn() {
                num ++;
                console.log(num);
                }
    清楚定时器：定时器的返回值是作为这个定时器的唯一标识，可以用来清除定时器。
                具体方法是：假设定时器setInterval()的返回值是参数1，那么clearInterval(参数1)就可以清除定时器。
                setTimeout()的道理是一样的。
    setTimeout() 的使用：
            延时调用。将一段代码，等待一段时间之后再执行。（只执行一次）
            参数1：回调函数，该函数会每隔一段时间被调用一次。
            参数2：每次调用的间隔时间，单位是毫秒。
            返回值：返回一个Number类型的数据。这个数字用来作为定时器的唯一标识，方便用来清除定时器。
        定义和清除定时器
            const timer = setTimeout(function() {
            console.log(1); // 3秒之后，再执行这段代码。
            }, 3000);

            setTimeout(() => {
            console.log(1); // 3秒之后，再执行这段代码。
            }, 3000);

防抖和节流
    函数防抖（debounce）
        就是指触发事件后在规定时间内函数只能执行一次，如果在 规定时间内又触发了事件，则会重新计算函数执行时间。
        简单的说，当一个动作连续触发，则只执行最后一次。
    函数节流（throttle）
        限制一个函数在规定时间内只能执行一次
    常见应用场景:
        函数防抖的应用场景
        连续的事件，只需触发一次回调的场景有：
            1.搜索框搜素输入，只需要用户最后一次输入完，在发送请求
            2.手机号 邮箱验证输入检测
            3.窗口大小的resize 只需要窗口调整完成后，计算窗口大小，防止重复渲染
        函数节流的应用场景
        间隔一段时间执行一次回调的场景有：
            1.滚动加载，加载更多，或滚动到底部监听
            2.谷歌搜索框，搜索联想功能
            3.高频点击提交，表单重复提交
        实现原理及代码封装
            以页面元素滚动监听的例子，来进行解析：
            函数节流：规定延迟时间（delay）内只执行最开始触发的函数
        


    
























