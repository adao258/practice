<!--
 * @Author: your name
 * @Date: 2022-02-10 10:20:57
 * @LastEditTime: 2023-04-04 11:29:11
 * @LastEditors: heyifan 1824186580@qq.com
 * @Description: 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
 * @FilePath: \Front-end development learning\document\notes\study notes\javascript\js随笔.md
-->

# 栈内存&堆内存

栈内存存放变量，堆内存存放对象

闭包中的基本数据类型不保存在栈内存，而是保存在堆内存栈:后进先出堆:是一个经过排序
的树形结构，每个节点都有一个值，引用数据类型在栈中存储了指针，该指针指向堆中的该
实体的起始地址，当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址之后从堆
中获取实体

闭包与堆内存: 闭包中的变量并不保存在栈内存当中，而是保存在堆内存中，这也就解释了
函数调用之后为什么闭包还能引用到函数内的变量

# 闭包

闭包指的是那些引用了另一个函数作用域中变量的函数，也就是内部函数可以访问外部函数的作用域
作用:保护函数的私有变量，形成不销毁的栈内存。把一些函数内的值保存下来，闭包可以实现方法和属性私有化
注意:闭包容易导致内存泄漏，

# 函数声明和函数表达式的区别

js 引擎在加载数据的时候对他们是区别对待的，js 引擎在任何代码执行之前，会先读取函数声明，并在执行上下文中生成函数定义，而函数表达式必须等到代码执行到他那一行，才会在执行上下文中生成函数定义。

# 垃圾回收

栈内存中的变量一般是在他的当前执行环境结束后就会被销毁，被垃圾回收机制回收堆内存
不会，因为不清楚其他的地方是不是还有一些对他的引用，堆内存中的变量只有在所有对他
的引用都结束的时候才会被回收

内存分配:声明变量，对象，函数的时候系统会为他们自动分配内存内存使用:使用变量或函
数的时候会读写内存内存回收:使用完毕，由垃圾回收机制自动回收不在使用

- 自动的垃圾回收机制找到那些不在使用的值，然后释放其占用的内存难点:找不到那些不
  需要在使用的变量，然而全局变量的声明周期直至浏览器卸载页面才会解决:

  1. 引用计数垃圾收集:这个算法定义的内存不再使用的标准很简单，就是看一个对象是否
     有指向他的引用，如果没有其他对象指向他了，说明该对象不在被需要了，缺点是不
     能由循环引用两个对象
  2. 标记清除算法:将不在使用的对象标记为无法到达的对象，就是从全局对象出发，定时
     扫描对象，凡是能从根部到达的对象，都是还需要使用的，那些无法由根部出发触及
     到的对象被标记为不再使用，稍后进行回收。常见的内存泄漏案例: 意外的全局变量
     被遗忘的定时器和回调函数闭包 DOM 引用

     如何避免内存泄漏: 减少不必要的全局变量，使用严格模式避免创建全局变量在使用
     完数据后及时解除引用，(闭包中的变量，dom 引用，定时器清除) 组织好逻辑，避免
     死循环

# new 操作符做了什么

new 运算符创建了一个用户定义的对象类型的实例或具有构造函数的内置对象的实例

参数: constructor:一个指定对象实例的类型的类或函数。 arguments:一个用于被
constructor 调用的参数列表。 new 关键字会进行如下操作

1. 创建一个空的简单 js 对象 {}
2. 为创建的对象添加 *proto*属性，将该属性链接至构造函数的原型对象
3. 将步骤 1 新创建的对象作为 this 的上下文，
4. 如果该函数没有返回对象，则返回 this

当代码 new Foo(...) 执行时，会发生以下事情：

1. 一个继承自 Foo.prototype 的新对象被创建
2. 使用指定的参数调用构造函数 Foo，并将 this 绑定到新创建的对象 new Foo 等同于
   new Foo()，也就是没有指定参数列表，Foo 不带任何参数调用的情况。
3. 由构造函数返回的对象就是 new 表达式的结果，如果构造函数没有显示返回一个对象，
   则使用步骤 1 创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动
   返回对象，来覆盖正常的对象创建步骤）

现在我们可以勇敢的回答，new 是用来做继承的，而创建对象的其实是
Object.create(null)。 在 new 操作符的作用下，我们使用新创建的对象去继承了他的构
造函数上的属性和方法、以及他的原型链上的属性和方法！

注意: 在构造函数里面返回引用类型时，构造函数里面的属性不能使用，只能使用返回的对
象在构造函数里面返回基本数据类型，和没有返回值的情况相同，构造函数不受影响

# this 指向问题

函数的调用方式决定了 this 的值(运行时绑定)，this 不能在执行期间被赋值，并且每次
函数被调用时 this 的值也可能不同

全局上下文:在全局执行函数中(在任何函数体外部)this 都指向全局对象函数上下文:在函
数内部，this 的值取决于函数被调用的方式(如果想要把 this 的值从一个环境传到另一个
环境，就要用 apply 或 call) 类上下文:this 在类中的表现和在函数中的表现类似，因为
类本质上也是函数，但也有一些区别。在类的构造函数中，this 是一个常规对象，类中所
有非静态方法都会被添加到 this 的原型中派生类:不像基类的构造函数，派生类的构造函
数没有初始的 this 绑定，在构造函数中调用 super 会生成一个 this 绑定，相当于执行
this = new Base()派生类不能在调用 super() 之前返回，除非其构造函数返回的是一个对
象，或者根本没有构造函数。

1. 箭头函数: 在箭头函数中 this 与封闭词法环境的 this 保持一致，在全局代码中，它
   将被设置为全局对象
2. 作为对象的方法:当函数作为对象里的方法被调用时，this 被设置为调用该函数的对象
3. 原型链中的 this:对于在原型链上某处定义的方法，同样的概念也适用，如果该方法存
   在于一个对象的原型上，那么 this 指向的是调用这个方法的对象，就像该方法就在这
   个对象上一样
4. getter 与 setter 中的 this: 当函数在 getter 与 setter 中被调用，用作 getter
   与 setter 的函数都会把 this 绑定到设置或获取属性的对象
5. 作为一个 dom 事件处理函数:当函数被用作事件处理函数时，他的 this 指向触发事件
   的元素
6. 作为一个内联事件处理函数:当代码被内联调用时，他的 this 指向见提起所在的 dom
   元素
7. 类中的 this: 和其他普通函数一样，方法中的 this 取决于他们如何被调用，有时，改
   写这个行为，让类中的 this 值总是指向这个类实例会很有用。

# 隐式类型转换

- 基本数据类型 Number String Boolean undefined null Bigint Symbol
- 引用数据类型 Object
- 隐式转换 1-true // 0 -- true 为 1，执行 1-1 1-null // 1 -- null 为 0，执行 1-0
  1\*undefined // NAN undefined 会转换为 NAN 2\*['5'] // 10 ['5']首先会变成 '5',
  然后再变成数字 5
- 加法的特殊性 (顺序即是优先级)
  1. 当一侧为 String 类型，被识别为字符串拼接，并会优先将另一侧转换为字符串
  2. 当一侧为 Number 类型，另一侧为原始类型(null,true)，则将原始类型转换为
     Number
  3. 当一侧为 Number 类型，另一侧为引用类型({} [] function)，将 number 类型和引
     用类型转换成字符串后拼接
- 逻辑语句中的类型转换单个变量 null undefined '' NAN 0 false 为 false，其他都为
  true 使用==比较中的 5 条规则
  1. NAN 和其他任何类型永远不相等返回 false(包括他自己)
  2. Boolean 和其他任何类型比较会先将 Boolean 转换为 Number 类型
  3. String 和 Number 比较会将 String 转为 Number 类型
  4. null == undefined 比较结果是 true,除此之外 null undefined 和其他任何其他结
     果比较都是 false
  5. 原始类型和引用类型作比较时，引用类型会依照 ToPrimitive 规则转换为原始类型(
     先 valueOf 后 toString 的模式 )如果没办法得到一个原始类型就会抛出 TypeError
- 特例
  1. [] == ![] ![] 会变成 false 按照规则 2 布尔值会变成 Number --> [] == 0 按照
     规则 3 string 和 number 比较会将 string 转为 number 0 == 0 所以答案为 true
  2. [undefined] == false [undefined] toString 变为 '' = false --> 0 == 0

# 埋点

前端埋点主要是为了运营以及开发人员采集用户行为数据，以及页面性能等数进行后续的数
据分析，举一些例子：比如，拿到页面在各种网络下的加载时间，再比如拿到用户在某个页
面的停留时间！

埋点的目的:

1. 性能监控: 白屏时长(页面从请求达到渲染条件，出现 ui 骨架的时间，请求域名到 dns
   解析完毕，返回页面骨架的时间) 重要页面的 http 请求时间重要页面的渲染时间首屏
   加载时间(页面所有动态内容加载完成时间，，其中包括 ajax 数据后渲染到页面的时间
   )
2. 数据监控 page view 访问来量(页面预览) Unique Visitor 访问数(唯一访客) 记录操
   作系统和浏览器记录用户在页面的停留时间进入当前页面的来源网页(也就是从哪进来的
   转化)

如何埋点:

1. 手动埋点(代码埋点，他的本质其实就是用 js 代码拿到一些基本信息，然后在一些特定
   的位置返回给服务端) 域名:document.domainURLdocument.URL 页面标题
   :document.title 分辨率:window.screen.height && window.screen.width 颜色深度
   :window.screen.colorDepth Referrer: document.referrer 客户端语言
   :navigator.language
2. 可视化埋点(用系统插入本来需要手动插入的埋点)
3. 无埋点(所谓无只是不需要工程师在业务代码里面插入侵入式的代码。只需要简单的加载
   了一段定义好的 SDK 代码，技术门槛更低，使用与部署也简单，避免了需求变更，埋点
   错误导致的重新埋点。)

# call & apply & bind

改变函数执行时的上下文

- call & apply 区别:

  Function.call(obj,[param1[,param2[,…[,paramN]]]]): 使用场景:对象的继承；借用方
  法

  1. 调用 call 的对象必须是一个函数 Function
  2. call 的第一个参数是一个对象，Function 的调用者将会指向这个对象，如果不传则
     默认为全局对象 window，
  3. 第二个参数开始可以接收任意个参数对象，每个参数会映射到相应位置的 Function
     的参数上。但是如果将所有的参数作为数组传入，它们会作为一个整体映射到
     Function 对应的第一个参数上，之后参数都为空。

  Function.apply(obj[,argArray]) 使用场景:Math.max;实现两个数组的合并

  1. 他的调用者必须是函数 Function 并且只接收两个参数，第一个参数与 call 一致，
  2. 第二个参数必须是数组或者类数组，他们会被转换成类数组，传入 function 中，并
     且会被映射到对应的参数上

  Function.bind(thisArg[, arg1[, arg2[, ...]]]) 解释:创建一个新的函数，在调用时
  设置 this 关键字为提供的值，并在调用新函数时，将给定参数列表作为原函数的参数序
  列的前若干项 bind 方法的返回值是函数，并且需要稍后调用，才会执行。而 apply 和
  call 则是立即调用。

  call 和 apply 的主要作用，是改变对象的执行上下文，并且是立即执行的。它们在参数
  上的写法略有区别。 bind 也能改变对象的执行上下文，它与 call 和 apply 不同的是
  ，返回值是一个函数，并且需要稍后再调用一下，才会执行。

# 首屏加载时间优化

1. cdn 分发(减少传输距离)，通过在多台服务器部署相同的副本，当用户访问时，服务器
   根据用户和哪台服务器距离进，来决定哪台服务器去响应这个请求
2. 后端在业务层的缓存，
3. 静态文件缓存方案
4. 前端的动态资源加载，动态路由加载组件动态加载图片懒加载
5. 合并请求
6. 页面使用骨架屏，在首屏加载完成之前，通过渲染一些简单元素进行占位。骨架屏的好
   处在于可以减少用户等待时的急躁情绪
7. 使用 ssr 渲染
8. 引入 http2.0
9. 利用好 http 压缩 gzip，
10. 利用好 script 标签的 async 和 defer 这两个属性。功能独立且不要求马上执行的
    js 文件，可以加入 async 属性。如果是优先级低且没有依赖的 js，可以加入 defer
    属性。

# proxy 和 Object.definedProxy

Object.definedProxy(obj,prop,description) 会直接在一个对象上定义一个新属性，或者
修改一个对象的现有属性，并返回此对象有三个问题: 不能监听数组的变化，数组的方法不
能触发必须遍历对象的每个属性必须深层遍历嵌套的对象，(当一个对象为深层嵌套时，必
须逐层遍历，直到把每个对象都调用到 Object.defineProperty 为止)Vue 源码中这样的逻
辑-walk 方法

proxy 支持数组：不需要对数组方法进行重载，省去了众多 hack 针对对象：针对整个对象
，而不是对象的某个属性 （省略了 Object.keys()的遍历。Reflect 是一个内置对象，提
供拦截 js 的方法。这些方法与处理器对象方法相同。Reflect 不是函数对象，因此它是不
可构造的。Reflect.get() Reflect.set() ）嵌套支持：get 里面递归调用 proxy 并返回

# 前端的登陆流程

初次登陆时，前端调后端的登陆接口，发送用户名和密码，后端收到请求，验证用户名和密
码，验证成功就返回一个 token，和一个用户信息的值，前端拿到 token，将 token 存储
到 vuex 中，然后从 vuex 中把 token 的值存入浏览器的 cookies 中，把用户信息存储到
vuex 然后再存储到 localStorage，然后跳转下一个页面，根据后端接口的要求，只要不登
陆就不能访问的页面需要在前端每次跳转页面时判断 cookies 中是否由 token，没有就跳
到登陆页面，有就跳到相应的页面，我们应该在每次发送 get/post 请求的时候带上
token，常用方法在项目 utils/service.js 中添加全局拦截器，将 token 的值放入请求头
中，后端判断请求头中有无 token，有 token 就拿到 token，并验证它是否过期，
在这里过期会返回无效的 token 然后有个跳回登陆页面重新登陆并且清除本地用户的信息。

# 前端权限管理

RBAC3 整合和 RBAC0，RBAC1，RBAC2 模型，是 RBAC 权限管理模型的集大成。
实现一个角色创建页面，用户可以创建新角色，并为其添加该用户自身所有的权限。
实现一个角色管理列表页，可以使用户在管理自己创建的角色。
实现一个角色分配页，用户可以为其指定用户分配该用户所拥有的角色
在用户登录有后端通常会返回一个权限表（数组，或则对象），通过权限表可以明确该用户所拥有的权限，可以在前端对资源访问，页面访问，数据访问，和操作控制做限制。

# vue 里面购物车的逻辑

- vue 中购物车逻辑的实现
  购物车信息用一个数组来存储，数组中保存对象，对象中有 id 和 count 属性，
  在 vuex 中 state 添加一个数据 cartList 用来保存这个数组
  由于商品详情页需要用到加入购物车功能，所以我们需要提供一个 mutation，用来将购物车信息加入 cardList 中
  加入购物车信息的时候，遵照如下规则，如果购物车中已经有了该商品信息，则数量累加，如果没有该商品信息，则新增一个对象
  在商品详情页，点击加入购物车按钮的时候，调用 vuex 提供的 addToCar 这个 mutation 将当前的商品信息传给 addToCart this.$store.commit("addToCart", {id: , count：})

# hash & history

前端路由的核心在于改变视图的同时不会向后端发送请求，因此有两种路由

hash
即地址栏 URL 中的#符号，比如这个 URL：http://www.abc.com/#/hello， hash 的值为 #/hello，他的特点在于，hash
虽然出现在 url 中，但不会被包括在 http 请求中，对吼端完全没有影响，因此改变 hash 不会重新加载页面

history
利用了 H5 新增的 HTML5 History Interface 中新增的 pushState()和 replaceState()方法，这两个方法应用于浏览器的历史记录栈，在当前已有的 go,back,forward 的基础之上，他们提供了对历史记录进行修改的功能，只是当他们执行修改时，虽然改变了当前的 url，但浏览器不会立即向后端发送请求

调用 history.pushState()相比于直接修改 hash，存在以下优势：
pushState()设置的新 URL 可以是与当前 URL 同源的任意 URL，而 hash 只可修改# 后面的部分，因此只能设置与当前 URL 同文档的 URL；
pushState()设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中； 而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；
pushState()通过 stateObject 参数可以添加任意类型的数据到记录中； 而 hash 只可添加短字符串；
pushState()可额外设置 title 属性供后续使用。 当然啦，history 也不是样样都好。 SPA 虽然在浏览器里游刃有余，但真要通过 URL 向后端发起 HTTP 请求时， 两者的差异就来了。尤其在用户手动输入 URL 后回车，或者刷新（重启）浏览器的时候。
hash 模式下，仅 hash 符号之前的内容会被包含在请求中， 如http://www.abc.com，因此对于后端来说，即使没有做到对路由的全覆盖， 也不会返回 404 错误。
history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致， 如http://www.abc.com/book/id 。如果后端缺少对/book/id 的路由处理，将返回 404 错误。 Vue-Router 官网里如此描述：“不过这种模式要玩好，还需要后台配置支持所以呢， 你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源， 则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。

history 的缺点
通过 history api，我们丢掉了丑陋的#，但是它也有个毛病： 不怕前进，不怕后退，就怕刷新，f5， （如果后端没有准备的话）,因为刷新是实实在在地去请求服务器的,不玩虚的。
在 hash 模式下，前端路由修改的是#中的信息，而浏览器请求时是不带它玩的， 所以没有问题.但是在 history 下，你可以自由的修改 path，当刷新时， 如果服务器中没有相应的响应或者资源，会分分钟刷出一个 404 来。

# map 和 forEach 的区别

forEach 针对每一个元素执行提供的函数，forEach 方法按升序为数组中含有效值的每一项执行一次 callback 函，那些已删除或者未初始化数的项将被跳过（例如在稀疏数组上）。
foreach 就是你按顺序一个一个跟他们做点什么，具体做什么，随便:

map 创建一个新数组，其中每一个元素由调用数组中的每一个元素执行提供的函数得来，map 做的事情和 for 循环 一样，不同的是， map 会创建一个新数组。
map 就是你手里拿一个盒子（一个新的数组），一个一个叫他们把钱包扔进去。结束的时候你获得了一个新的数组，里面是大家的钱包，钱包的顺序和人的顺序一一对应。

结论：forEach 会修改原来的数组，而 map 方法会得到一个新的数组并返回。

# MVC

Model：数据模型的概念，可以把他当成从数据库里面查询出来后的一条数据，或者将查询出来的元数据经过处理后的一个特定的数据模型结构
View：视图
Controller：是数据模型与视图之间的桥梁，实际界面层的各种变化都要经过他的控制，而且像用户从界面提交的数据也会经过 Controller 的组装检查生成数据模型，然后改变数据库里的数据内容。

mvc
如果想把数据从数据库里面渲染到页面上，先要查询完数据库，将拿到的元数据进行一些处理，然后在给到页面的模板引擎，进行数据组装，最后组合完成进行渲染后生成的 html 格式文件供浏览器展示使用

mvvm
本来是从数据库拿到数据 -- 对数据进行一些处理 -- 通过模板引擎(ejs,jade)渲染到视图上
现在是拿到数据 -- 在 script 里面对数据进行一些处理 -- 通过 html 将视图渲染出来

如何将数据模型与视图绑定起来是非常关键的异步，vue 是通过 object.defineProperty 实现

# 执行上下文与作用域

变量或函数的上下文决定了他们可以访问哪些数据，以及他们的行为，

上下文中的代码在执行的时候，会创建变量对象的一个作用域链，这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序，代码正在执行的上下文的变量对象始终位于作用域链的最前端。
如果上下文是函数，则其活动对象（activation object）用作变量对象。活动对象最初只有
一个定义变量：arguments。（全局上下文中没有这个变量。）作用域链中的下一个变量对象来自包含上
下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；全局上下文的变量对象始终
是作用域链的最后一个变量对象。

# 暂存性死区

是指 let const 在声明之前不能被调用，如果在声明之前使用，就会出现暂存行死区，报 referenceError

let 不允许在相同作用域内声明同一个变量，

# 渲染机制

处理 html 并构建 dom 树
处理 css 构建 cssOm 树
将 DOM 与 CSSOM 合并成⼀个渲染树
根据渲染树来布局，计算每个节点的位置
调⽤ GPU 绘制，合成图层，显示在屏幕上。

在构建 CSSOM 树时，会阻塞渲染，直⾄ CSSOM 树构建完成。并且构建 CSSOM 树是⼀个
⼗分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择
器，执⾏速度越慢。
当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地⽅重新开始。也
就是说，如果你想⾸屏渲染的越快，就越不应该在⾸屏就加载 JS ⽂件。并且 CSS 也会影响
JS 的执⾏，只有当解析完样式表才会执⾏ JS，所以也可以认为这种情况下，CSS 也会暂停
构建 DOM。

# 扩展运算符

console.log(...[1,2,3,4,5,6])
console.log([...'hello'])
与解构赋值相结合 如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。

应用:
复制数组
合并数组
实现了 Iterator 接口的对象，任何定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组。扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。
替代函数的 apply 方法

# 宏任务与微任务

宏任务包括：script,setTimeout,setInterval,I/O,UI 交互事件,postMessage,MessageChannel,setImmediate,UI Rending
微任务包括：Promise.then,Object.observe,MutationObserver,process.nextTick

# Object && Array

显示的创建 object 的实例有两种方法，第一种是使用 new 操作符和 object 构造函数
另一种方法是使用对象字面量

Array.from(arrayLike[, mapFn[, thisArg]]),对一个类数组或可迭代对象创建一个新的，浅拷贝的数组实例
可用于: 从 string,map,set ,类数组对象生成数组

Array.of()可以把一组参数变成数组，这个方法用于替代在 ES6 之前常用的 Array.prototype.slice.call(arguments)
ECMAScript 提供了 Array.isArray()方法。这个方法的目的就是确定一个值是否为数组，而不用管它是在哪个全局执行上下文中创建的。

# ES6 新特性

let const 变量声明

结构赋值

模板字符串

函数的扩展(arguments 参数)，箭头函数

新增的数组方法(find findIndex indexof)

新增的对象方法(is assign key values entries)

symbol

set map

promise

generotar async await

class

module

# js 中数据在栈和堆中的存储方式

栈内存:他会自动内存空间，自动释放，存放基本数据类型
堆内存:他是动态分配内存空间，大小不固定，不自动释放，存储引用数据类型。
