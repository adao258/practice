<!--
 * @Author: your name
 * @Date: 2022-02-10 10:20:57
 * @LastEditTime: 2022-02-11 17:15:05
 * @LastEditors: Please set LastEditors
 * @Description: 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
 * @FilePath: \Front-end development learning\document\notes\study notes\javascript\js随笔.md
-->

# 堆内存&栈内存

栈内存存放变量，堆内存存放对象

闭包中的基本数据类型不保存在栈内存，而是保存在堆内存
栈:后进先出
堆:是一个经过排序的树形结构，每个节点都有一个值，引用数据类型在栈中存储了指针，该指针指向堆中的该实体的起始地址，当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址之后从堆中获取实体

闭包与堆内存:
闭包中的变量并不保存在栈内存当中，而是保存在堆内存中，这也就解释了函数调用之后为什么闭包还能引用到函数内的变量

# 垃圾回收

栈内存中的变量一般是在他的当前执行环境结束后就会被销毁，被垃圾回收机制回收
堆内存不会，因为不清楚其他的地方是不是还有一些对他的引用，堆内存中的变量只有在所有对他的引用都结束的时候才会被回收

内存分配:声明变量，对象，函数的时候系统会为他们自动分配内存
内存使用:使用变量或函数的时候会读写内存
内存回收:使用完毕，由垃圾回收机制自动回收不在使用

- 自动的垃圾回收机制
  找到那些不在使用的值，然后释放其占用的内存
  难点:找不到那些不需要在使用的变量，然而全局变量的声明周期直至浏览器卸载页面才会
  解决:

  1. 引用计数垃圾收集:这个算法定义的内存不再使用的标准很简单，就是看一个对象是否有指向他的引用，如果没有其他对象指向他了，说明该对象不在被需要了，缺点是不能由循环引用两个对象
  2. 标记清除算法:将不在使用的对象标记为无法到达的对象，就是从全局对象出发，定时扫描对象，凡是能从根部到达的对象，都是还需要使用的，那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。
     常见的内存泄漏案例:
     意外的全局变量
     被遗忘的定时器和回调函数
     闭包
     DOM 引用

     如何避免内存泄漏:
     减少不必要的全局变量，使用严格模式避免创建全局变量
     在使用完数据后及时解除引用，(闭包中的变量，dom 引用，定时器清除)
     组织好逻辑，避免死循环

# new 操作符做了什么

new 运算符创建了一个用户定义的对象类型的实例或具有构造函数的内置对象的实例

参数:
constructor:一个指定对象实例的类型的类或函数。
arguments:一个用于被 constructor 调用的参数列表。
new 关键字会进行如下操作

1. 创建一个空的简单 js 对象 {}
2. 为创建的对象添加 *proto*属性，将该属性链接至构造函数的原型对象
3. 将步骤 1 新创建的对象作为 this 的上下文，
4. 如果该函数没有返回对象，则返回 this

当代码 new Foo(...) 执行时，会发生以下事情：

1. 一个继承自 Foo.prototype 的新对象被创建
2. 使用指定的参数调用构造函数 Foo，并将 this 绑定到新创建的对象 new Foo 等同于 new Foo()，也就是没有指定参数列表，Foo 不带任何参数调用的情况。
3. 由构造函数返回的对象就是 new 表达式的结果，如果构造函数没有显示返回一个对象，则使用步骤 1 创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）

现在我们可以勇敢的回答，new 是用来做继承的，而创建对象的其实是 Object.create(null)。 在 new 操作符的作用下，我们使用新创建的对象去继承了他的构造函数上的属性和方法、以及他的原型链上的属性和方法！

注意:
在构造函数里面返回引用类型时，构造函数里面的属性不能使用，只能使用返回的对象
在构造函数里面返回基本数据类型，和没有返回值的情况相同，构造函数不受影响

# this 指向问题

函数的调用方式决定了 this 的值(运行时绑定)，this 不能在执行期间被赋值，并且每次函数被调用时 this 的值也可能不同

全局上下文:在全局执行函数中(在任何函数体外部)this 都指向全局对象
函数上下文:在函数内部，this 的值取决于函数被调用的方式(如果想要把 this 的值从一个环境传到另一个环境，就要用 apply 或 call)
类上下文:this 在类中的表现和在函数中的表现类似，因为类本质上也是函数，但也有一些区别。在类的构造函数中，this 是一个常规对象，类中所有非静态方法都会被添加到 this 的原型中
派生类:不像基类的构造函数，派生类的构造函数没有初始的 this 绑定，在构造函数中调用 super 会生成一个 this 绑定，相当于执行 this = new Base()派生类不能在调用 super() 之前返回，除非其构造函数返回的是一个对象，或者根本没有构造函数。

1. 箭头函数: 在箭头函数中 this 与封闭词法环境的 this 保持一致，在全局代码中，它将被设置为全局对象
2. 作为对象的方法:当函数作为对象里的方法被调用时，this 被设置为调用该函数的对象
3. 原型链中的 this:对于在原型链上某处定义的方法，同样的概念也适用，如果该方法存在于一个对象的原型上，那么 this 指向的是调用这个方法的对象，就像该方法就在这个对象上一样
4. getter 与 setter 中的 this: 当函数在 getter 与 setter 中被调用，用作 getter 与 setter 的函数都会把 this 绑定到设置或获取属性的对象
5. 作为一个 dom 事件处理函数:当函数被用作事件处理函数时，他的 this 指向触发事件的元素
6. 作为一个内联事件处理函数:当代码被内联调用时，他的 this 指向见提起所在的 dom 元素
7. 类中的 this: 和其他普通函数一样，方法中的 this 取决于他们如何被调用，有时，改写这个行为，让类中的 this 值总是指向这个类实例会很有用。

# 隐式类型转换

- 基本数据类型
  Number String Boolean undefined null Bigint Symbol
- 引用数据类型
  Object
- 隐式转换
  1-true // 0 -- true 为 1，执行 1-1
  1-null // 1 -- null 为 0，执行 1-0
  1\*undefined // NAN undefined 会转换为 NAN
  2\*['5'] // 10 ['5']首先会变成 '5', 然后再变成数字 5
- 加法的特殊性 (顺序即是优先级)
  1. 当一侧为 String 类型，被识别为字符串拼接，并会优先将另一侧转换为字符串
  2. 当一侧为 Number 类型，另一侧为原始类型(null,true)，则将原始类型转换为 Number
  3. 当一侧为 Number 类型，另一侧为引用类型({} [] function)，将 number 类型和引用类型转换成字符串后拼接
- 逻辑语句中的类型转换
  单个变量
  null undefined '' NAN 0 false 为 false，其他都为 true
  使用==比较中的 5 条规则
  1. NAN 和其他任何类型永远不相等返回 false(包括他自己)
  2. Boolean 和其他任何类型比较会先将 Boolean 转换为 Number 类型
  3. String 和 Number 比较会将 String 转为 Number 类型
  4. null == undefined 比较结果是 true,除此之外 null undefined 和其他任何其他结果比较都是 false
  5. 原始类型和引用类型作比较时，引用类型会依照 ToPrimitive 规则转换为原始类型(先 valueOf 后 toString 的模式 )如果没办法得到一个原始类型就会抛出 TypeError
- 特例
  1. [] == ![]
     ![] 会变成 false
     按照规则 2 布尔值会变成 Number --> [] == 0
     按照规则 3 string 和 number 比较会将 string 转为 number 0 == 0 所以答案为 true
  2. [undefined] == false
     [undefined] toString 变为 '' = false --> 0 == 0

# 埋点
