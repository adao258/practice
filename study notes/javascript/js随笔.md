<!--
 * @Author: your name
 * @Date: 2022-02-10 10:20:57
 * @LastEditTime: 2022-02-14 13:37:03
 * @LastEditors: Please set LastEditors
 * @Description: 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
 * @FilePath: \Front-end development learning\document\notes\study notes\javascript\js随笔.md
-->

# 堆内存&栈内存

栈内存存放变量，堆内存存放对象

闭包中的基本数据类型不保存在栈内存，而是保存在堆内存
栈:后进先出
堆:是一个经过排序的树形结构，每个节点都有一个值，引用数据类型在栈中存储了指针，该指针指向堆中的该实体的起始地址，当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址之后从堆中获取实体

闭包与堆内存:
闭包中的变量并不保存在栈内存当中，而是保存在堆内存中，这也就解释了函数调用之后为什么闭包还能引用到函数内的变量

# 垃圾回收

栈内存中的变量一般是在他的当前执行环境结束后就会被销毁，被垃圾回收机制回收
堆内存不会，因为不清楚其他的地方是不是还有一些对他的引用，堆内存中的变量只有在所有对他的引用都结束的时候才会被回收

内存分配:声明变量，对象，函数的时候系统会为他们自动分配内存
内存使用:使用变量或函数的时候会读写内存
内存回收:使用完毕，由垃圾回收机制自动回收不在使用

- 自动的垃圾回收机制
  找到那些不在使用的值，然后释放其占用的内存
  难点:找不到那些不需要在使用的变量，然而全局变量的声明周期直至浏览器卸载页面才会
  解决:

  1. 引用计数垃圾收集:这个算法定义的内存不再使用的标准很简单，就是看一个对象是否有指向他的引用，如果没有其他对象指向他了，说明该对象不在被需要了，缺点是不能由循环引用两个对象
  2. 标记清除算法:将不在使用的对象标记为无法到达的对象，就是从全局对象出发，定时扫描对象，凡是能从根部到达的对象，都是还需要使用的，那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。
     常见的内存泄漏案例:
     意外的全局变量
     被遗忘的定时器和回调函数
     闭包
     DOM 引用

     如何避免内存泄漏:
     减少不必要的全局变量，使用严格模式避免创建全局变量
     在使用完数据后及时解除引用，(闭包中的变量，dom 引用，定时器清除)
     组织好逻辑，避免死循环

# new 操作符做了什么

new 运算符创建了一个用户定义的对象类型的实例或具有构造函数的内置对象的实例

参数:
constructor:一个指定对象实例的类型的类或函数。
arguments:一个用于被 constructor 调用的参数列表。
new 关键字会进行如下操作

1. 创建一个空的简单 js 对象 {}
2. 为创建的对象添加 *proto*属性，将该属性链接至构造函数的原型对象
3. 将步骤 1 新创建的对象作为 this 的上下文，
4. 如果该函数没有返回对象，则返回 this

当代码 new Foo(...) 执行时，会发生以下事情：

1. 一个继承自 Foo.prototype 的新对象被创建
2. 使用指定的参数调用构造函数 Foo，并将 this 绑定到新创建的对象 new Foo 等同于 new Foo()，也就是没有指定参数列表，Foo 不带任何参数调用的情况。
3. 由构造函数返回的对象就是 new 表达式的结果，如果构造函数没有显示返回一个对象，则使用步骤 1 创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）

现在我们可以勇敢的回答，new 是用来做继承的，而创建对象的其实是 Object.create(null)。 在 new 操作符的作用下，我们使用新创建的对象去继承了他的构造函数上的属性和方法、以及他的原型链上的属性和方法！

注意:
在构造函数里面返回引用类型时，构造函数里面的属性不能使用，只能使用返回的对象
在构造函数里面返回基本数据类型，和没有返回值的情况相同，构造函数不受影响

# this 指向问题

函数的调用方式决定了 this 的值(运行时绑定)，this 不能在执行期间被赋值，并且每次函数被调用时 this 的值也可能不同

全局上下文:在全局执行函数中(在任何函数体外部)this 都指向全局对象
函数上下文:在函数内部，this 的值取决于函数被调用的方式(如果想要把 this 的值从一个环境传到另一个环境，就要用 apply 或 call)
类上下文:this 在类中的表现和在函数中的表现类似，因为类本质上也是函数，但也有一些区别。在类的构造函数中，this 是一个常规对象，类中所有非静态方法都会被添加到 this 的原型中
派生类:不像基类的构造函数，派生类的构造函数没有初始的 this 绑定，在构造函数中调用 super 会生成一个 this 绑定，相当于执行 this = new Base()派生类不能在调用 super() 之前返回，除非其构造函数返回的是一个对象，或者根本没有构造函数。

1. 箭头函数: 在箭头函数中 this 与封闭词法环境的 this 保持一致，在全局代码中，它将被设置为全局对象
2. 作为对象的方法:当函数作为对象里的方法被调用时，this 被设置为调用该函数的对象
3. 原型链中的 this:对于在原型链上某处定义的方法，同样的概念也适用，如果该方法存在于一个对象的原型上，那么 this 指向的是调用这个方法的对象，就像该方法就在这个对象上一样
4. getter 与 setter 中的 this: 当函数在 getter 与 setter 中被调用，用作 getter 与 setter 的函数都会把 this 绑定到设置或获取属性的对象
5. 作为一个 dom 事件处理函数:当函数被用作事件处理函数时，他的 this 指向触发事件的元素
6. 作为一个内联事件处理函数:当代码被内联调用时，他的 this 指向见提起所在的 dom 元素
7. 类中的 this: 和其他普通函数一样，方法中的 this 取决于他们如何被调用，有时，改写这个行为，让类中的 this 值总是指向这个类实例会很有用。

# 隐式类型转换

- 基本数据类型
  Number String Boolean undefined null Bigint Symbol
- 引用数据类型
  Object
- 隐式转换
  1-true // 0 -- true 为 1，执行 1-1
  1-null // 1 -- null 为 0，执行 1-0
  1\*undefined // NAN undefined 会转换为 NAN
  2\*['5'] // 10 ['5']首先会变成 '5', 然后再变成数字 5
- 加法的特殊性 (顺序即是优先级)
  1. 当一侧为 String 类型，被识别为字符串拼接，并会优先将另一侧转换为字符串
  2. 当一侧为 Number 类型，另一侧为原始类型(null,true)，则将原始类型转换为 Number
  3. 当一侧为 Number 类型，另一侧为引用类型({} [] function)，将 number 类型和引用类型转换成字符串后拼接
- 逻辑语句中的类型转换
  单个变量
  null undefined '' NAN 0 false 为 false，其他都为 true
  使用==比较中的 5 条规则
  1. NAN 和其他任何类型永远不相等返回 false(包括他自己)
  2. Boolean 和其他任何类型比较会先将 Boolean 转换为 Number 类型
  3. String 和 Number 比较会将 String 转为 Number 类型
  4. null == undefined 比较结果是 true,除此之外 null undefined 和其他任何其他结果比较都是 false
  5. 原始类型和引用类型作比较时，引用类型会依照 ToPrimitive 规则转换为原始类型(先 valueOf 后 toString 的模式 )如果没办法得到一个原始类型就会抛出 TypeError
- 特例
  1. [] == ![]
     ![] 会变成 false
     按照规则 2 布尔值会变成 Number --> [] == 0
     按照规则 3 string 和 number 比较会将 string 转为 number 0 == 0 所以答案为 true
  2. [undefined] == false
     [undefined] toString 变为 '' = false --> 0 == 0

# 埋点

前端埋点主要是为了运营以及开发人员采集用户行为数据，以及页面性能等数进行后续的数据分析，举一些例子：比如，拿到页面在各种网络下的加载时间，再比如拿到用户在某个页面的停留时间！

埋点的目的:

1. 性能监控:
   白屏时长(页面从请求达到渲染条件，出现 ui 骨架的时间，请求域名到 dns 解析完毕，返回页面骨架的时间)
   重要页面的 http 请求时间
   重要页面的渲染时间
   首屏加载时间(页面所有动态内容加载完成时间，，其中包括 ajax 数据后渲染到页面的时间)
2. 数据监控
   page view 访问来量(页面预览)
   Unique Visitor 访问数(唯一访客)
   记录操作系统和浏览器
   记录用户在页面的停留时间
   进入当前页面的来源网页(也就是从哪进来的转化)

如何埋点:

1. 手动埋点(代码埋点，他的本质其实就是用 js 代码拿到一些基本信息，然后在一些特定的位置返回给服务端)
   域名:document.domainURLdocument.URL
   页面标题:document.title
   分辨率:window.screen.height && window.screen.width
   颜色深度:window.screen.colorDepth
   Referrer: document.referrer
   客户端语言:navigator.language
2. 可视化埋点(用系统插入本来需要手动插入的埋点)
3. 无埋点(所谓无只是不需要工程师在业务代码里面插入侵入式的代码。只需要简单的加载了一段定义好的 SDK 代码，技术门槛更低，使用与部署也简单，避免了需求变更，埋点错误导致的重新埋点。)

# call & apply & bind

改变函数执行时的上下文

- call & apply 区别:

  Function.call(obj,[param1[,param2[,…[,paramN]]]]):
  使用场景:对象的继承；借用方法

  1. 调用 call 的对象必须是一个函数 Function
  2. call 的第一个参数是一个对象，Function 的调用者将会指向这个对象，如果不传则默认为全局对象 window，
  3. 第二个参数开始可以接收任意个参数对象，每个参数会映射到相应位置的 Function 的参数上。但是如果将所有的参数作为数组传入，它们会作为一个整体映射到 Function 对应的第一个参数上，之后参数都为空。

  Function.apply(obj[,argArray])
  使用场景:Math.max;实现两个数组的合并

  1. 他的调用者必须是函数 Function 并且只接收两个参数，第一个参数与 call 一致，
  2. 第二个参数必须是数组或者类数组，他们会被转换成类数组，传入 function 中，并且会被映射到对应的参数上

  Function.bind(thisArg[, arg1[, arg2[, ...]]])
  解释:创建一个新的函数，在调用时设置 this 关键字为提供的值，并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项
  bind 方法的返回值是函数，并且需要稍后调用，才会执行。而 apply 和 call 则是立即调用。

  call 和 apply 的主要作用，是改变对象的执行上下文，并且是立即执行的。它们在参数上的写法略有区别。
  bind 也能改变对象的执行上下文，它与 call 和 apply 不同的是，返回值是一个函数，并且需要稍后再调用一下，才会执行。

# 首屏加载时间优化

1. cdn 分发(减少传输距离)，通过在多台服务器部署相同的副本，当用户访问时，服务器根据用户和哪台服务器距离进，来决定哪台服务器去响应这个请求
2. 后端在业务层的缓存，
3. 静态文件缓存方案
4. 前端的动态资源加载，
   动态路由加载
   组件动态加载
   图片懒加载
5. 合并请求
6. 页面使用骨架屏，在首屏加载完成之前，通过渲染一些简单元素进行占位。骨架屏的好处在于可以减少用户等待时的急躁情绪
7. 使用 ssr 渲染
8. 引入 http2.0
9. 利用好 http 压缩 gzip，
10. 利用好 script 标签的 async 和 defer 这两个属性。功能独立且不要求马上执行的 js 文件，可以加入 async 属性。如果是优先级低且没有依赖的 js，可以加入 defer 属性。

# proxy 和 Object.definedProxy

Object.definedProxy(obj,prop,description) 会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象
有三个问题:
不能监听数组的变化，数组的方法不能触发
必须遍历对象的每个属性
必须深层遍历嵌套的对象，(当一个对象为深层嵌套时，必须逐层遍历，直到把每个对象都调用到 Object.defineProperty 为止)Vue 源码中这样的逻辑-walk 方法

proxy
支持数组：不需要对数组方法进行重载，省去了众多 hack
针对对象：针对整个对象，而不是对象的某个属性 （省略了 Object.keys()的遍历。Reflect 是一个内置对象，提供拦截 js 的方法。这些方法与处理器对象方法相同。Reflect 不是函数对象，因此它是不可构造的。Reflect.get() Reflect.set() ）
嵌套支持：get 里面递归调用 proxy 并返回
