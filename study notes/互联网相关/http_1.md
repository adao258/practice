## 第一章 HTTP 概述

- Web 客户端与服务器如何通信的
  web 的内容是存储在 web 服务器上面的(例如网页 HTML，音频，视频，文本)，这些服务器存储了数据，当 HTTP 客户端发起请求，服务器会在 HTTP 响应中回送所请求的数据。因此 HTTP 的客户端和 HTTP 的服务器共同构成了万维网的基本组件(最常见的 web 客户端就是浏览器)
- 表示 web 内容的资源来自何方
  web 服务器是 web 资源的宿主，web 资源是 web 内容的源头，最简单的 web 资源就是 web 服务器里面的静态文件。例如:文本文件，HTML 文件，图片，音频，视频。还有动态资源，它可以根据你的身份，所请求的信息或每天不同的时段来产生内容。
- 媒体类型:
  web 传输的对象都有 MIME(多用途因特网邮件扩展) 类型的数据格式标签。当 web 浏览器从服务器取回一个对象的时候，会查看相关的 MIME 类型，看他是否知道如何处理这个对象
  1. MIME 类型是一种文本标记，表示一种主要的类型和一个特定的子类型，中间由一条斜杠分割
  2. html 格式的文本文档由 text/html 类型来标记
  3. 普通的 ASCII 文本文档由 text/plain 类型来标记
  4. JPEG 版本的图片为 image/jpeg 类型来标记
  5. GIF 格式的图片欸 image/gif 类型标记
- URI 有两种形式 URL 和 URN
  每个服务器资源都有一个名字被称为统一资源标识符。他的作用就类似于邮政地址一样，是唯一标识并定位信息资源
- URL
  统一资源定位符: 他描述了一台特定服务器上某资源的特定位置
  url 分为三个部分
  1. 第一部分称为协议(http://)
  2. 第二部分给出了地址(www.baidu.com)
  3. 其余部分指定了 web 服务器上的某个资源(/a/b/c)
- URN
  统一资源名: URN 是作为特定内容的唯一名称使用的，与目前的资源所在地无关，通过 URN 就可以对同一个名字通过多种协议来访问资源
- HTTP 几种常见的请求方法(GET, PUT, POST, HEAD, DELETE )
- HTTP 报文: 分为请求报文和响应报文
  1. 起始行: 报文的第一行就是起始行，在请求报文中来说明要做些什么，在响应报文中说明出现了什么情况
  2. 首部字段: 起始行后面有零个或多个首部字段，每个首部字段都包含一个名字和一个值，两者之间用冒号
  3. 主体: 在空行之后就是可选报文的主体，其中包含了所有类型的数据
- 在报文响应之后就可以通过 TCP 传输控制协议连接从一个地方搬移到另一个地方去
- HTTP 协议是应用层协议，它无需操心网络通信的具体细节，联网的细节都交给了 TCP/IP 网络传输协议。TCP/IP 提供了(无差错的数据传输;按序传输;未分段的数据流)
- HTTP(应用层) -> TCP(传输层) -> IP(网络层) -> 网络特有的链路接口(数据链路层) -> 物理网络硬件(物理层)
- 在 HTTP 客户端向服务器发送报文之前，需要用到网络协议 IP 地址和端口号在客户端和服务器之间简历一条 TCP/IP 协议
- 步骤

  1. 浏览器从 URL 解析出服务器的主机名
  2. 历览器将服务器的主机名转换为服务器的 IP 地址
  3. 浏览器将端口号从 URL 中解析出来
  4. 浏览器建立一条与 WEB 服务器的 TCP 连接
  5. 浏览器向服务器发送一条 HTTP 请求报文
  6. 服务器向浏览器发送一条 HTTP 响应报文
  7. 关闭连接， 浏览器显示文档

- 协议版本
  http 0.9
  只支持 get 写法，不支持多媒体内容的 MINE 类型，各种 http 首部，或版本号，他的初衷是为了获取 html 对象
  http 1.0
  添加了版本号，各种 http 首部，一些额外的方法，以及对多媒体对象的处理
  http 1.0+
  持久的 keep-alive 连接，虚拟主机支持，代理连接支持
  http 1.1
  矫正 http 设计中的结构性，明确的语义，引入下性能优化措施
  http-NG(http 2.0)
  重点关注的是性能优化，以及更强大的服务逻辑远程执行框架
- web 结构组件
  1. 代理: 位于客户端和服务器之间的 HTTP 中间实体
  2. 缓存: HTTP 的仓库，使常用页面的副本可以保存离客户端更近的地方
  3. 网关: 连接其他应用程序的特殊 WEB 服务器
  4. 隧道: 对 HTTP 协议进行盲转发的特殊代理
  5. Agent 代理: 发起自动 HTTP 请求的半智能 WEB 客户端
- 代理:他位于客户端和服务器之间，接受客户端的所有 http 请求，并将这些请求转发给服务器(期间可以对请求进行修改之后转 发)
- 缓存: web 缓存或代理缓存
- 网关: 是一种特殊的服务器，作为其他服务器的中间实体使用，通常用于将 http 流量转换成其他协议，就好像一个服务器一样
- 隧道: 是建立起来之后在两条连接之间对原始数据进行盲转发的 HTTP 应用程序，它通常在一条或者多条 HTTP 连接上转发非 HTTP 数据，转发时不会窥探数据
- Agent 代理: 是代表用户发起 HTTP 请求的客户端程序，

## 第二章 URL 与资源

查询字符串:问号右边的内容 query 称为查询组件
片段: frag 片段组件表示一个资源内部片段，通常在#右边

http 服务器通常只处理整个对象，而不是对象的片段，客户端不能将片段传送给服务器，浏览器从服务器获取了整个资源后，会根据片段来显示你感兴趣的那部分资源

url 字符集

## 第三章 HTTP 报文

- HTTP 报文是在 HTTP 应用程序之间发送的数据块，

- 报文是如何流动的

报文的发送者都是在接收者的上游，因此报文是向下流动的(不管是请求还是响应)

- 报文的组成: 对报文进行描述的起始行(start line)；包含属性的首部块(header)；以及可选的包含数据的主体块(body)
  请求报文

  ```
  <method> <request-URl> <version>
  <headers>
  <entity-body>
  ```

  响应报文

  ```
  <version> <states> <response-phrase>
  <headers>
  <entity-body>
  ```

  首部
  通用首部：既可以出现在请求首部又可以出现在响应首部
  请求首部:提供更多请求有关的信息
  响应首部:提供更多响应有关的信息
  实体首部:描述主体的长度和内容，或资源本身
  扩展首部:规范中没有定义的新首部

- 请求和响应报文的区别
- 请求报文支持的各种方法
- 和响应报文一起返回各种状态码
- 各种各样的 http 首部都是用来做什么的
- **状态码**
- 信息状态码
  100 收到了请求的初始部分，请客户端继续，发送了这个状态码之后，服务器在收到请求之后必须响应
  101 说明服务器正在根据客户端的指定，将协议切换成 update 首部所列字段
- 成功状态码
  200 OK 请求没问题，实体的主体部分包含了所有请求资源
  201 created 用于创建服务器对象的请求，响应的实体主体部分中应该包含各种引用了已经创建的资源的 url，Location 首部包含的则是最具体的引用，
  202 accepted 请求已被接收，但服务器还未对其进行任何动作，不能保证服务器会完成这个请求，服务器因该在实体的主体部分，包含对请求状态的描述
  203 non-authoritative-information 实体首部，包含的信息不是来自于源服务器，而是来自资源的一份副本
  204 no content 相应报文包含若干首部和一个状态行，但没有实体的主体部分，主要用于浏览器不转为显示新文档的情况下，对其进行更新(你如刷新一个表单页面)
  205 reset content 另一个主要用于浏览器的代码，负责告知浏览器清除当前页面中的所有 html 表单元素
  206 partial content 成功执行了一个部分或范围的请求，客户端可以通过一种特殊的首部来获取部分或某个范围内的文档
- 重定向状态码
  300 multiple choices 客户端请求一个实际指向多个资源的 url 时会返回的状态码，服务器可以在 location 首部包含资源所处的 url
  301 在请求的 url 已被移除时使用，响应的 location 首部中应该包含资源现在所处的 url
  302 found 与 301 类似，但是客户端应该使用 location 首部给出的 url 来临时定位资源，将来的请求仍应使用老的 url
  303 告诉客户端应该用另一个 url 来获取资源，新的 url 位于响应报文的 location 首部，其主要目的是允许 post 请求的响应，将客户端定向到某个资源上去
  304 客户端可以通过所包含的请求首部，使其请求变成有条件的，带有这个状态码的响应不应该包含实体的主体部分，
  305 用来说明必须通过一个代理来访问资源，
  307 与 301 类似
- 客户端错误状态码
  400 客户端发送了一个错误的请求
  401 与适当的首部一起返回，在这些首部中请求客户端在获取对资源的访问前，对自己进行认证，
  402
  403 用于说明请求被服务器拒绝了，如果服务器想说明为什么拒绝请求，可以包含实体的主体部分来对原因进行描述，但这个状态码通常是在服务器不想说明拒绝原因的时候使用的
  404 说明服务其无法找到所请求的 url，通常会包含一个实体，以便客户端应用程序显示给用户看
  405 发起的请求中带有所请求的 url 不支持的方法时，使用此状态码，应该在响应中包含 allow 首部，已告知客户端对所请求的资源可以使用哪些方法，
  406 客户端可以指定参数来说明他们愿意接收什么类型的实体，服务器没有与客户端可接受的 url 匹配的资源时，使用此代码
  407 与 401 类似，但要求对资源进行认证的代理服器
  408 如果客户端所花的请求太长，服务器可以返回次状态码并关闭连接
  409 用于说明请求可能在资源上引发一些冲突，响应中应包含描述冲突的主体
  410 与 404 类似，只是服务器曾经拥有过此资源
  - 服务器错误状态码
    500 服务器遇到一个妨碍他为请求提供服务时的错误
    501 客户端发出的请求超出服务器的能力范围
    502 作为代理或网关使用的服务器从请求响应链的下一条链路上收到了一条伪响应
    503 用来说明服务器现在无法为请求提供服务，但将来可以
    504 与 408 类似，这里的响应来自一个网关或代理，他们在等待另一个服务器对其请求进行响应时超时了
    505 服务器收到的请求使用了他无法或不愿支持的协议版本时
- **首部**
  通用首部(http1.0 引入了缓存首部)
  提供了与报文相关的最基本的信息，不论报文是什么类型，都为其提供一些有用的信息
  Connection 允许客户端和服务器指定与请求/响应连接有关的选项
  Date 提供日期和事件标志，说明报文是什么时候创建的
  MIME-Version 给出了发送端使用的 MIME 版本
  Trailer 如果报文采用了分块传输编码方式就可以用这个首部列出报文拖挂部分的首部的集合
  Transfer-Encoding 告知接收端为了保证报文的可靠传输，，对报文采用了什么编码方式
  Update 给出了发送端可能想要升级使用的新版本或协议
  Via 显示了报文经过的中间节点
  Cache-Control 用于随报文传送缓存指示
  Pragma 另一种随报文传送指示的方式，但并不专用于缓存
- 请求首部
  Client-IP 运行客户端的 ip 地址
  From 客户端用户的 e-mail 地址
  Host 接收请求的服务器的主机名和端口号
  Referer 包含当前请求的 URI 的文档的 URL
  UA-Color 客户端显示器的显示颜色有关信息
  UA-Cpu 客户端 cpu 的类型或制造商
  UA-Disp 客户端显示器(屏幕)能力有关的信息
  UA-Os 运行在客户端机器上的操作系统名称及版本
  UA-pixels 客户端显示器的像素信息
  User-Agent 将发起请求的应用程序名称告知服务器

  1. Accept 首部
     为客户端提供了一种将其喜好和能力告知服务器的方式，包括他们想要什么，可以使用什么，不想要什么，最重要的什么，服务器就可以根据这些额外外信息，对发送的内容做出决定
     Accept 告诉服务器能够发送哪些媒体类型
     Accept-Charset 告诉服务器能够发送哪些字符集
     Accept-Encoding 告诉服务器能够发送哪些编码方式
     Accept-Language 告诉服务器能够发送哪些语言
     TE 告诉服务器可以使用哪些扩展传输编码
  2. 请求条件首部
     Expect 允许客户端列出某请求所要求的服务器行为
     If-Match 如果实体标记与文档前的实体标记相匹配，就获取这份文档
     If-Modified-Since 除非在某个指定的日期之后资源被修改过，否则就限制这个请求
     If-None-Match 如果提供的实体标记与当前文档的实体标记不相符，就获取文档
     If-Range 允许对文档的某个范围进行条件请求
     If-Unmodified-Since 除非在某个指定日期之后资源没有被修改过，否则就限制这个请求，
     Range 如果服务器支持范围请求，就请求资源的指定范围
  3. 安全请求首部
     Authorization 包含了客户端提供给服务器，以便对其自身进行认证的数据
     Cookie 客户端用它向服务器传送一个令牌，他并不是真正的安全首部，但确实隐含了安全功能
     Cookie2 用来说明请求端支持的 cookie 版本
  4. 代理请求支持
     Max-Forward 在通往源端服务器的路径上，将求转发给其他代理或网关的最大次数，与 trace 方法一起使用
     Proxy-Authorization 与 Authorization 首部相同，但这个首部是在与代理进行认证时使用的
     Proxy-Connection 与 Connection 首部相同，但这个首部是在与代理建立连接时使用的

- 响应首部
  Age 从最初创建开始，响应持续时间
  Public 服务器为其资源支持的请求方法列表
  Petry-After 如果资源不可用的话，再次日期或时间重试
  Server 服务器应用程序软件的名称和版本
  Title 对 html 文档来说，就是他的 title
  Waring 比原因短语中更详细一些的警告报文
  1. 协商首部
     Accept-Ranges 对此资源来说，服务器可接收的范围类型
     vary 服务器查看的其他首部列表，可能会使响应发生变化
  2. 安全响应首部
     Proxy-Authorization 来自代理的对客户端的质询列表
     Set-Cookie 不是真正的安全首部，但隐含安全功能，可以在客户端设置一个令牌，以便服务器对客户端进行标识
     Set-Cookie2 与 Set-Cookie 类似
     WWW-Authorization 来自服务器对客户端的质询列表
  3. 实体首部
     Allow 列出来可以对此实体执行的请求方法
     Location 告知客户端实体实际上位于何处，用于将接收端定向到资源的
  4. 内容首部
     Content-Base 解析主体中的相对 URL 时使用的基础 URL
     Content-Encoding 对主体执行的任意编码方式
     Content-Language 理解主体时最适宜使用的自然语言
     Content-Length 主体的长度或尺寸
     Content-Location 资源实际所处的位置
     Content-MD5 主题的 MD5 校验
     Content-Range 在整个资源中此实体表示的字节范围
     Content-Type 这个主体的对象类型
  5. 实体缓存首部
     ETag 与此实体相关的是实体标记
     Expires 实体不再有效，要从原始的源端再次获取此实体的日期和时间
     Last-Modified 这个实体最后一次被修改的日期和时间

## 第四章 连接管理

- HTTP:HTTP(应用层) -> TCP(传输层) -> IP(网络层) -> 网络接口(数据链路层)
- HTTPS: HTTP(应用层) -> SSL OR TLS(安全层) -> TCP(传输层) -> IP(网络层) -> 网络接口(数据链路层)
- TCP 连接是通过四个值来识别的<源 ip 地址， 源端口号， 目的 IP 地址，目的端口号>
- HTTP 事务延迟
  1. 客户端需要根据 URI 来确定 web 服务器的 ip 地址和端口号，如果最近没有对 URI 中的主机名进行访问，通过 DNS 解析系统将 URI 中的主机名转换成一个 ip 地址可能需要花费数十秒的时间
  2. 接下来，客户端会向服务器发送一条 TCP 连接请求，并等待服务器响应，每条 TCP 连接都会有一两秒的时延，但是如果有上百条的连接会叠加连接时间
  3. 连接成功后，因特网请求报文，响应报文都会耗费时间
  4. 发送 HTTP 响应会花费时间
- 常见的 TCP 相关时延

  1. tcp 连接建立握手
     建立一条新的 tcp 连接，甚至是在发送任意数据之前，tcp 软件之间会交换一系列的 ip 分组，如果连接只用来传送少量的数据，这些交换过程就会降低 http 性能
     - tcp 握手的步骤
       请求新的 tcp 连接时，客户端要向服务器发送一个小的 tcp 分组(40-60 字节)这个分组设置列一个特殊的 SYN 标记，说明这是一个连接请求。
       如果服务器接受了连接，就会对一些连接参数进行计算，向客户端回送一个 tcp 分组，这个分组中的 SYN 和 ACK 标记都被置位，说明连接请求已被接收。
       最后客户端向服务端回送一条信息，通知他连接已经成功建立，现代的 tcp 栈都允许客户端在这个确认分组中发送数据
       最后的结果是:小的 http 事物可能会在 tcp 连接上花费 50%的时间
  2. tcp 慢启动拥塞控制
     tcp 连接会随着时间进行自我调谐，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移来提高传输的速度，这种协调被称为 tcp 慢启动，用于防止因特网的过载和拥塞
  3. 数据聚集的 Nagle 算法
     tcp 有一个数据流接口，应用程序可以通过它将任意尺寸的数据放入 tcp 栈中，即使一次只放一个字节也可以，但是每个 tcp 段中都至少装载了 40 个字节的标记和首部，所以如果 tcp 发送了大量的包含少量数据的分组，网络的性能就会严重下降。
     Nagle 算法试图在发送一个分组之前，将大量 tcp 数据绑定在一起，以提高网络的效率。
     而 Nagle 算法里，小的报文可能无法填满一个分组，可能因为等待那些永远不会到来的数据而延时，其次 Nagle 算法与延迟确认之间的交互存在问题，Nagle 算法会阻止数据的发送，直到有确认分组抵达时，但确认分组自身会被延迟确认算法延迟 100-200ms。
     Http 应用程序通常会在自己的栈中设置参数 TCP_NODELAY，这样做的话一定要保证向 TCP 写入大块的数据
  4. 用于捎带确认的 tcp 延迟算法
  5. TIME_WAIT 累积和端口耗尽
     TIME_WAIT 端口耗尽时很严重的性能问题，会影响到性能的基准。
     当某个 tcp 端点关闭 tcp 连接时，会在内存中维护一个小的控制块，用来记录最近所关闭连接的 ip 地址所有端口号，这类信息会维持两分钟左右，以确保在这段时间内不会创建具有相同地址和端口号的连接

- 提高 HTTP 性能
  1. 并行连接: 通过多条 TCP 连接发起并发的 HTTP 请求
  2. 持久连接: 重用 TCP 连接，以消除连接及关闭时延(类似于缓存，在请求一次 web 站点后，服务器会将 tcp 连接保持在打开的状态，知道服务器关闭为止)
  3. 持久连接以及并行连接配合使用: 持久连接有两种类型
     HTTP/1.0 + keep alive
     HTTP/1.1 + persistent
  4. 管道化连接: 通过共享的 TCP 连接发起并发的 HTTP 请求
  5. 复用的连接: 交替传送请求和响应的报文

总结: 主机名转换成 ip 地址需要 10s，每条 tcp 连接 2s，请求报文，响应报文

## 第五章 web 服务器

- 实际的 web 服务器会做些什么
  建立连接:接受一个客户端连接，或者如果不希望与这个客户端连接就将其关闭
  接受请求:从网络中读取一条 http 请求报文
  处理请求:对请求报文进行解释，并采取行动
  访问资源:访问报文中指定的资源
  构建响应:创建带有正确首部的 http 响应报文
  发送响应:将相应回送给客户端
  记录事务处理过程:将与已完成事物有关的内容记录在一个日志文件里面

## 第六章 代理

- 代理分为单个代理和公共代理
- 代理和网关的对比
  代理连接的是两个或多个使用相同协议的应用程序。网关连接的则是两个或多个使用不同协议的端口
- 代理服务器的部署
  1. 出口代理
  2. 入口代理
  3. 反向代理
  4. 网络交换代理
- 动态选择父代理
  1. 负载均衡
  2. 地理位置附近的路由
  3. 协议/类型路由
  4. 基于订购的路由

## 第七章 缓存

- 缓存解决的问题
  1. 冗余的数据传输
  2. 带宽瓶颈
  3. 瞬间拥塞
  4. 距离延时
- 缓存的处理过程
  1. 接收--缓存从网络中读取抵达的请求报文
  2. 解析--缓存对读取的报文进行解析，提取出 url 和各种首部
  3. 查询--缓存查看是否有本地副本可用，如果没有就获取一份副本，并将其保存到本地
  4. 新鲜度检测--缓存查看副本是否新鲜，不是就向服务器询问是否有更新
  5. 创建响应--缓存会用新的首部和已缓存的主体来构建以一条响应报文
  6. 发送--缓存通过网络将响应发送回客户端
  7. 日志--描述这个事务

## 第八章 集成点: 网关 隧道 中继

-
-
-
-
-
-
-
-
-
-
-
