<!--
 * @Author: your name
 * @Date: 2022-02-15 15:30:48
 * @LastEditTime: 2022-04-12 09:42:36
 * @LastEditors: Please set LastEditors
 * @Description: 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
 * @FilePath: \Front-end development learning\document\notes\study notes\互联网相关\网络随笔.md
-->

# token cookie sessionStorage localStorage

sessionStorage & localStorage
相同点:
储存大小为 5m 左右
都有同源限制策略
仅在客户端中保存，不参与和服务器的通信

差异:

1. 声明周期-数据可以存储多长时间
   localStorage 存储的数据是永久性的，除非认为删除，不然一直都在
   sessionStorage 与存储数据的脚本所在的标签页的有效期是相同的，一旦窗口或者标签被关闭，数据就会被删除
2. 作用域-谁拥有数据的访问权
   localStorage:在同一个浏览器内，同源文档之间共享 localStorage 数据，可以互相读取覆盖
   sessionStorage: 与 localStorage 一样需要同一浏览器同源文档这一条件。不仅如此，sessionStorage 的作用域还被限定在了窗口中，也就是说，只有同一浏览器、同一窗口的同源文档才能共享数据。

cookie

1. 大小限制为 4KB 左右
2. 主要用途是保存登录信息和标记用户(比如购物车)等,不过随着 localStorage 的出现，现在购物车的工作 Cookie 承担的较少了
3. 一般有服务器生成，可设置生效时间，如果在浏览器端生成 cookie，默认是关闭浏览器后失效
4. 每次都会携带在 http 头中，如果使用 cookie 保存过多的数据会带来新能问题
5. 原生 API 不如 storage 友好，需要自己封装函数

生成: 浏览器访问网站第一次发出请求的时候，服务器会响应并在响应头里面添加一个 Set-Cookie 选项，浏览器第二次发送请求的时候会通过 cookie 请求头部将 cookie 信息发送给服务器，服务端会辨别用户身份，另外，Cookie 的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。

1. Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2018 07:28:00 GMT;//可以指定一个特定的过期时间（Expires）或有效期（Max-Age）
2. document.cookie='age=20;domain=.baidu.com'

缺陷:
不够大
过多的 cookie 会带来性能浪费
由于在 http 请求中的 cookie 是明文传递的，所以安全性成问题，除非用 https

安全:
https
设置 htmlOnly 标记

token 的存储问题

# https

流程: 客户端相服务器发起 SSL 握手，服务器返回了一个 SSL 证书，证书里面包含公钥 PUB\*KEY --> 客户端验证 SSL 证书是否有效，有效则生成 AES_KEY 并使用书中的公钥进行加密得到 AES_KEY_SECRET --> 使用 AES_KEY 对报文进行加密传输

CA 认证体系

# 浏览器输入 url 后的处理

前提条件:
一个 Chrome 浏览器
一台 Linux 服务器
发起 HTML 请求
不考虑任何缓存和优化机制
采用 HTTP/1.1 + TLS/1.2 + TCP 协议

DNS 解析过程
首先，浏览器向本地 DNS 服务器发起请求，由于本地 DNS 服务器没有缓存不能直接将域名转换为 IP 地址，需要采用递归或者迭代查询的方式（图 3）依次向根域名服务器、顶级域名服务器、权威域名服务器发起查询请求，直至找到一个或一组 IP 地址，返回给浏览器。

HTTP 请求过程
拿到 ip 地址后,浏览器在通过系统调用 socket 接口与服务器 443 端口进行通信,整个过程可以分解为建立连接,发送 http 请求,返回 http 响应,维持连接,释放连接五个部分,

建立连接

# UDP & TCP

Tcp 协议是一种面向连接的，可靠的数据传输服务，可靠性指的是通过 TCP 协议传输数据可以无差错，不丢失，不重复，并且按序到达

他有以下特点
双方在连接建立之后，都可以在任何时候进行数据发送
有缓存，发送和接收时都可以利用缓存临时存放数据
tcp 时面向字节流的

- tcp 的三次握手和四次挥手
  三次握手(Three-way Handshake)是指，建立一个 tcp 连接时，需要客户端和服务器总共发三个包，三次握手的主要目的是连接服务器指定端口，建立 tcp 连接，并同步连接双方的序列号和确认号，交换 tcp 窗口大小信息，在 socket 编程中，客户端执行 connect() 时。将触发三次握手。

  第一次握手: (syn=1,seq=x) 客户端发送一个 tcp 的 syn 标志位置 1 的包，指明客户端打算连接的服务器的端口，以及初始序列 X，保存在包的头的序列号(Sequence Number)字段里，发送完毕后，客户端进入 syn_send 状态
  第二次握手:(syn=1,ack=1,seq=y,ACKnum=x+1) 服务器发回确认包(ack)应答，即 syn 标志位和 ack 标志位均为 1，服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加 1，即 X+1，发送完毕后，服务器端进入 SYN_RCVD 状态。
  第三次握手:(ack=1，acknum = y+1)客户端再次发送确认包(ACK)，SYN 标志位为 0，ACK 标志位为 1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写 ISN 的+1
  发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。

  四次挥手
  TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。

  第一次挥手(FIN=1，seq=x)
  假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为 1 的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。
  发送完毕后，客户端进入 FIN_WAIT_1 状态。
  第二次挥手(ACK=1，ACKnum=x+1)
  服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。
  发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。
  第三次挥手(FIN=1，seq=y)
  服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为 1。
  发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个 ACK。
  第四次挥手(ACK=1，ACKnum=y+1)
  客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT 状态，等待可能出现的要求重传的 ACK 包。
  服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。
  客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。

- SYN 攻击
  什么是 SYN 攻击（SYN Flood）？
  在三次握手过程中，服务器发送 SYN-ACK 之后，收到客户端的 ACK 之前的 TCP 连接称为半连接(half-open connect)。此时服务器处于 SYN_RCVD 状态。当收到 ACK 后，服务器才能转入 ESTABLISHED 状态.
  SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的 IP 地址，向服务器不断地发送 SYN 包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的 SYN 包将长时间占用未连接队列，正常的 SYN 请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。
  SYN 攻击是一种典型的 DoS/DDoS 攻击。
  如何检测 SYN 攻击？
  检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。
  如何防御 SYN 攻击？
  SYN 攻击不能完全被阻止，除非将 TCP 协议重新设计。我们所做的是尽可能的减轻 SYN 攻击的危害，常见的防御 SYN 攻击的方法有如下几种
  缩短超时（SYN Timeout）时间
  增加最大半连接数
  过滤网关防护
  SYN cookies 技术

UDP 协议是无连接的，不可靠的
无连接
不可靠
面向报文
支持 n 对 n 的交互通信
UDP 无拥塞控制

# http 1.0 1.1 2.0 的主要区别

http1.0 无状态，无连接的应用层协议
无状态:服务器不跟踪不记录请求的状态
无连接:浏览器每次请求都需要建立 tcp 连接

http1.0 规定浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 tcp 连接，服务器处理完成后立即断开 tcp 连接(无连接)，服务器不跟踪每个客户端也不记录过去的请求(无状态)

缺点:
无连接导致无法复用连接，每次发送请求的时候都需要进行一次 tcp 连接，而 tcp 的连接释放过程又是比较费事的，导致网络的利用率非常低，
无连接导致队头阻塞，因为 http1.0 规定下一个请求必须在前一个请求响应到达之前才能发送，如果一个请求一直响应不到，那么下一个请求就会被阻塞

http1.1
长连接:http1.1 新增了一个 connection 字段，通过设置 keep-alive 可以保持连接不断开，避免了重复连接 tcp，提高了网络利用率，如果客户端想关闭 http 连接，可以在请求头中携带 connection:false 来告知服务器关闭请求
支持请求管道化:管线化使得请求可以并行传输，HTTP 管道化可以让我们把先进先出队列从客户端（请求队列）迁移到服务端（响应队列）。但 还是无法解决阻塞的问题

http1.1 支持管道化，但是服务器必须一个一个的响应，这是一个很大的缺陷。但我们可以打开多个 tcp 连接，也就是通过多个请求同时进行来达到并行的目的

http2.0
帧:与逻辑消息对应的完整的一系列数据帧
流:存在于连接中的一个虚拟通道，流可以承载双向消息，每个流都有一个唯一的整数 ID
消息:http2.0 数据通信的最小单位是消息，例如请求和响应等，消息由一个或多个帧组成

二进制分帧
http2.0 采用 2 进制格式传递数据，而非 1.0 里面的文本格式，二进制协议解析起来更加高效，http1.0 的响应和请求报文都是由起始行，首部和实体组成，各部分之间 以文本换行符分割，http2.0 佳能请求和响应数据分割为更小的帧，并且他们采用二进制编码

多路复用
同域名下，所有的通信都在单个连接中完成
单个连接可以承载任意数量的双向数据流
数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可乱序发送，因为根据帧首部流标识可以重新组装

这一特性的好处:
同域名下只需要占用一个 tcp 连接，消除了因多个 tcp 连接而带来的延时和内存消耗
单个连接上可以并行交错地请求和响应，之间互不干扰
http2.0 中每个请求都可以携带一个 31bit 的优先值，0 表示最高优先级，数值越大优先级越低，有了这个优先级，客户端和服务端就可以在处理并不同的流时采用不同的策略，以最有的方式发送流，消息，帧

服务器推送:
服务端在发送页面 html 时主动推送其他资源，而不用等到浏览器解析到相应的位置，发起请求和响应，例如服务端可以主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 时再发送这些请求。
服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送 RST_STREAM 帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三方资源给客户端。

头部压缩:
在 http1.x 中头部元数据都是以纯文本的形式发送的，通常会给每个请求增加 500~800 字节的负荷
比如说 cookie，默认情况下，浏览器会在每次请求的时候，把 cookie 附在 header 上面发送给服务器。（由于 cookie 比较大且每次都重复发送，一般不存储信息，只是用来做状态记录和身份认证）
HTTP/2.0 使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小。高效的压缩算法可以很大的压缩 header，减少发送包的数量从而降低延迟。

保存草稿之后提交 -- update -- amtCode == amtType = 中文数据
直接提交 -- update -- amtCode == amtType = 数值
存为草稿在添加数据提交 -- update -- amtCode == amtType = 中文数据;amtCode == amtType = 数值 之前存为草稿的为中文数据，新增的提交为数字

草稿提交：提交完直接返回上一个页面
直接提交

# 301 302

- 301
  请求的网页已被永久的移动到新位置，服务器返回此响应时会自动将请求者转到新位置，
  永久转移

- 302
  服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置。
  暂时转移

301 和 302 状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的 URL 地址
这个地址可以从响应的 Location 首部中获取（用户看到的效果就是他输入的地址 A 瞬间变成了另一个地址 B）——这是它们的共同点。
他们的不同在于。301 表示旧地址 A 的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；302 表示旧地址 A 的资源还在（仍然可以访问），

这个重定向只是临时地从旧地址 A 跳转到地址 B，搜索引擎会抓取新的内容而保存旧的网址。为什么尽量要使用 301 跳转？——网址劫持！
